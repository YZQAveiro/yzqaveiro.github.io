<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>C++（持续更新） | YZQAveiro</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://yzqaveiro.github.io/favicon.ico?v=1650940908228">
<link rel="stylesheet" href="https://yzqaveiro.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="C++ Day01
命名空间
// 为避免命名冲突，引入了命名空间的概念

// 1. 命名空间的定义
// 命名空间是一个由用户自己定义的作用域，在不同作用域中可以定义相同名字的变量或函数，这些变量或函数被称为实体（也可以是常量、结构体、..." />
    <meta name="keywords" content="C++" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://yzqaveiro.github.io">
        <img src="https://yzqaveiro.github.io/images/avatar.png?v=1650940908228" class="site-logo">
        <h1 class="site-title">YZQAveiro</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      Welcome to YZQAveiro's Blog!
    </div>
    <div class="site-footer">
       | <a class="rss" href="https://yzqaveiro.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">C++（持续更新）</h2>
            <div class="post-date">2022-04-26</div>
            
            <div class="post-content" v-pre>
              <h2 id="c-day01"><code>C++ Day01</code></h2>
<h3 id="命名空间">命名空间</h3>
<pre><code class="language-c++">// 为避免命名冲突，引入了命名空间的概念

// 1. 命名空间的定义
// 命名空间是一个由用户自己定义的作用域，在不同作用域中可以定义相同名字的变量或函数，这些变量或函数被称为实体（也可以是常量、结构体、类等），其可见域始于实体创建，终于所在命名空间结束

// 2. 命名空间的使用方式
// (1) using 编译指令

using namespace std; // 标准命名空间

// (2) 作用域限定符

int main()
{
	std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl; // 使用 :: 符号来调用命名空间内的实体    
}

// (3) using 声明机制

using std::cout;
using std::endl;
int main()
{
	cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl; // using 的作用域是从 using 语句开始到所在作用域结束
}

// 3. 匿名命名空间
// 匿名命名空间没有名字，只能在本文件的作用域内有效，其作用域是匿名命名空间的声明语句开始到文件结束

namespace
{

int val = 0; // 可以在本模块内部使用，类似 static 变量
void func()
{
	cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl;
}
    
}
</code></pre>
<h3 id="const"><code>const</code></h3>
<pre><code class="language-c++">// 1. const 修饰变量

const int num1 = 10;
int const num2 = 20;
const int val; // 错误写法，使用 const 关键字修饰的变量必须要初始化

// 2. const 修饰指针

int num1 = 10, num2 = 20;
const int* p1 = &amp;num1; // 1. 常量指针
*p1 = 100; // 错误，不能修改所指内容的值
p1 = &amp;num2; // 正确，可以改变指针的指向

int const* p2 = &amp;num1; // 实质同 1

int* const p3 = &amp;num1; // 2. 指针常量
*p3 = 100; // 正确，可以改变所指内容的值
p3 = &amp;num2; // 错误，不能改变指针的指向

const int* const p4 = &amp;num1; // 3. const 指针常量：所指内容的值和指针的指向均不能改变
</code></pre>
<h3 id="newdelete"><code>new/delete</code></h3>
<pre><code class="language-c++">// 1. 开辟一个元素的空间

int* p = new int(1); // 将整型指针所指的值初始化为括号内的值

// 2. 开辟一个数组的空间

int* p = new int[10](); // [] 内定义了数组大小，所有元素初始化为 0

/* 常考题：new/delete 表达式与 malloc/free 的区别与联系
1) malloc/free 是 C/C++ 语言的标准库函数，new/delete 是 C++ 的表达式
2) new 能够自动分配空间大小，malloc 需要传入参数
3) new 开辟空间的同时还对空间做了初始化的操作，而 malloc 不行
4) new/delete 能对对象进行构造和析构函数的调用，进而对内存进行更加详细的工作，而malloc/free 不能
5) new/delete 的功能完全覆盖了 malloc/free, 但 C++ 程序经常要调用 C 函数，而 C 程序只能用 malloc/free 管理动态内存，因此 C++ 中仍保留 malloc/free
*/
</code></pre>
<h3 id="引用">引用</h3>
<pre><code class="language-c++">// 引用：一个已定义变量的别名
// 引用的本质：间接寻址 (* const)

// 1. 引用作为函数参数（以两数交换为例）

void swap(int x, int y) // 值传递，本质是将参数拷贝进函数栈，无法实现两数交换
{
	int temp = x;
	x = y;
	y = temp;
}

void swap(int *pa, int *pb) // 用指针作为参数，本质仍为值传递
{
    int temp = *pa;
    *pa = *pb;
    *pb = temp;
}

void swap(int &amp;x, int &amp;y) // 引用作为参数
{
	int temp = x;
	x = y;
	y = temp;
}


// 2. 引用作为函数返回值

int func1() // 当函数返回时，会对 temp 进行复制
{
    temp = 100;
    return temp; // 此处会进行复制操作
}
int&amp; func2() // 当函数返回时，不会对 temp 进行复制，因为返回的是引用
{
    temp = 1000;
    return temp;
}

int num = func2() + 1; // 错误，会发生内存泄露
</code></pre>
<h3 id="强制转换">强制转换</h3>
<pre><code class="language-c++">// 1. static_cast
/* static_cast的用法主要有以下几种：
1) 用于基本数据类型之间的转换，如把 int 转成 char, 把 int 转成 enum.
2) 把 void 指针转换成目标类型的指针，但不安全（注意：不能随意转换两个任意类型的指针）
3) 把任何类型的表达式转换成 void 类型
4) 用于类层次结构中基类和派生类之间指针或引用的转换。进行上行转换（把派生类的指针或引用转换成基类指针或引用）是安全的；进行下行转换（把基类指针或引用转换成派生类指针或引用）时，由于没有动态类型检查，所以是不安全的 */ 

int iNumber = 100;
float fNumber = 0;
fNumber = (float) iNumber; // C 中的强制转换
fNumber = static_cast&lt;float&gt;(iNumber);

void *pVoid = malloc(sizeof(int));
int *pInt = static_cast&lt;int*&gt;(pVoid); // 将 void 指针转换为其他类型的指针
float *pFloat = static_cast&lt;float *&gt;(pInt);// 错误，不能在任意的指针类型间转换

// 2. const_cast
// 该运算符用来修改类型的 const 属性。常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。

const int num = 1;
const int* p1 = &amp;num;
int* p2 = const_cast&lt;int*&gt;(&amp;num); // 将 const int* 转换为 int*
</code></pre>
<h3 id="函数重载">函数重载</h3>
<pre><code class="language-c++">// C++ 进行函数重载的实现原理叫名字改编 (name mangling), 具体的规则是:
// 1. 函数名称必须相同
// 2. 参数列表必须不同（参数的类型不同、个数不同、顺序不同）
// 3. 函数的返回类型可以相同也可以不相同
// 4. 仅仅返回类型不同不足以成为函数的重载

int add(int x, int y);
int add(int x, int y, int z);
// 通过 nm [filename] 查看调用函数信息
0000000000001169 T _Z3addii
0000000000001181 T _Z3addiii
    
// extern &quot;C&quot;
// C++ 源码中，如需某些代码按 C 的方式调用，必须将其放入 extern &quot;C&quot; {} 中
// 可用 #ifdef __cplusplus #endif 来使 C++ 编译器使用 C 编译方式编译宏定义内代码
0000000000001169 T add
</code></pre>
<h3 id="默认参数">默认参数</h3>
<pre><code class="language-c++">// 不为函数传递实参时，函数可按事先定义好的默认参数运行，通常将默认参数设置在函数声明中
void func1(int a = 0, int b = 0, int c = 0, int d = 0);
void func1(int a = 0, int b, int c, int d = 0); // 错误，一旦设置默认参数，后续参数均需设置默认参数
</code></pre>
<h3 id="bool类型"><code>bool</code>类型</h3>
<pre><code class="language-c++">// true: 1   false: 0
// 任何数字或指针值都可以隐式转换为 bool 值
// 任何非零值都将转换为 true, 而零值转换为 false
// 一个 bool 类型的值所占内存大小为 1
</code></pre>
<h3 id="内联函数inline">内联函数<code>(inline)</code></h3>
<pre><code class="language-c++">// 1. 内联函数的定义
// 内联函数是 C++ 特有的特性，用于降低程序的运行时间。在编译阶段，编译器将内联函数的定义体替代函数调用语句，从而实现类似带参数宏定义的效果

// 2. 将内联函数放入头文件
// inline 关键字必须与函数定义体放在一起才能构成内联函数，即：

inline void func(int x, int y){
	// function
}
// 原则：声明前不加 inline, 定义前加 inline
</code></pre>
<h3 id="异常安全">异常安全</h3>
<pre><code class="language-c++">// C++ 处理异常的三个关键字：try, catch, throw

// (1) throw: 问题出现时，程序通过使用 throw 抛出异常
// 格式：throw [表达式];

// (2) try-catch 语句块：标识特定的异常并进行捕获
// 基本流程：执行 try 块中的语句 --&gt; 如果执行的过程中没有异常拋出，那么执行完后就执行最后一个 catch 块后面的语句，所有 catch 块中的语句都不会被执行；如果 try 块执行的过程中拋出了异常，那么拋出异常后立即跳转到第一个异常类型和拋出的异常类型匹配的 catch 块中执行（称作异常被该 catch 块捕获），执行完后再跳转到最后一个 catch 块后面继续执行
</code></pre>
<h2 id="c-day02"><code>C++ Day02</code></h2>
<h3 id="c风格字符串"><code>C</code>风格字符串</h3>
<pre><code class="language-c">// C 风格字符串是以 '\0' 为结尾的字符数组

// 常用的字符串处理函数
// 返回 str 的长度，不包括 null 结束符
size_t strlen( const char *str );

// 比较lhs和rhs是否相同。lhs等于rhs,返回0; lhs大于rhs，返回正数; lhs小于rhs，返回负数
int strcmp( const char *lhs, const char *rhs );
int strncmp( const char *lhs, const char *rhs, size_t count );

// 在 str 中查找首次出现 ch 字符的位置；查找不到，返回空指针
char *strchr( const char *str, int ch );

// 在 str 中查找首次出现子串 substr 的位置；查找不到，返回空指针
char *strstr( const char* str, const char* substr );

// 字符控制函数 (修改式操作)
char *strcpy(char *dest, const char *src); // 将 src 复制给 dest, 返回 dest
char *strncpy(char *dest, const char *src, size_t count);
char *strcat( char *dest, const char *src ); // 拼接
char *strncat( char *dest, const char *src, size_t count );
</code></pre>
<h3 id="c风格字符串-2"><code>C++</code>风格字符串</h3>
<pre><code class="language-c++">// C++ 提供 std::string 用于字符串处理，实质是对 C 标准库中 string.h 的封装

// 1. string 对象的构造

// (1) 默认构造函数，生成一个空字符串
string();
// (2) 通过 C 风格字符串构造一个 string 对象
string(const char* rhs);
// (3) 通过 rhs 的前 n 个字符构造一个 string 对象
string(const char* rhs, size_type n);
// (4) 复制拷贝构造函数
string(const string&amp; rhs);
// (5) 生成一个 string 对象，包含 n 个 c 字符
string(size_type n, char c);
// (6) 以区间 [first, last) 内的字符创建一个 string 对象
string(InputIt first, InputIt last);

// 2. string 与 C 风格字符串的转换

string str = &quot;hello&quot;;
const char* cstr = str.c_str();
// const char* cstr = str.data();
cout &lt;&lt; cstr &lt;&lt; endl; // hello

// 3. 元素遍历和存取

// (1) 使用运算符 [] 或 at() 访问

reference operator[]( size_type pos );// 返回下标为 pos 的元素
const_reference operator[]( size_type pos ) const;
reference at( size_type pos );// 返回下标为 pos 的元素
const_reference at( size_type pos ) const;

string str = &quot;hello&quot;;
cout &lt;&lt; str[0] &lt;&lt; &quot; &quot; &lt;&lt; str.at(1) &lt;&lt; endl; // h e

// (2) 使用迭代器访问特殊位置

iterator begin(); // 首字符
const_iterator begin() const;
iterator end(); // 尾字符后的字符
const_iterator end() const;
reverse_iterator rbegin(); // 尾字符
const_reverse_iterator rbegin() const;
reverse_iterator rend(); // 首字符前的字符
const_reverse_iterator rend() const;

string str = &quot;hello&quot;;
cout &lt;&lt; *str.begin() &lt;&lt; &quot; &quot; &lt;&lt; *str.rbegin() &lt;&lt; &quot; &quot; &lt;&lt; *(str.end() - 1) &lt;&lt; &quot; &quot; &lt;&lt; *(str.rend() - 1) &lt;&lt; endl; // h o o h
// 此时 rbegin 和 rend 的地址计算方法与通常情况相反

// 4. 字符串的长度和容量相关

bool empty() const; // 字符串是否为空
size_type size() const; // 字符串大小
size_type length() const; // 字符串长度，与 size 所得结果一致
size_type capacity() const; // 字符串容量
size_type max_size() const; // 所能创建的最长字符串的长度

// 5. 元素追加和相加

string &amp;operator+=(const string &amp; tr);
string &amp;operator+=(CharT ch);
string &amp;operator+=(const CharT* s);
string &amp;append(size_type count, CharT ch);
string &amp;append(const basic_string &amp; str);
string &amp;append(const CharT* s);
string &amp;append(InputIt first, InputIt last);
string operator+(const string &amp; lhs, const string &amp; rhs);
string operator+(const string &amp; lhs, const char* rhs);
string operator+(const char* lhs, const string &amp; rhs);
string operator+(const string &amp; lhs, char rhs);
string operator+(char lhs, const string &amp; rhs);

// 6. 提取子串

string substr(size_type pos = 0, size_type count = npos) const;

// 7. 元素删除

iterator erase(iterator position);
iterator erase(const_iterator position);
iterator erase(iterator first, iterator last);

// 8. 元素清空

void clear();

// 9. 字符串比较

bool operator==(const string &amp; lhs, const string &amp; rhs);
bool operator!=(const string &amp; lhs, const string &amp; rhs);
bool operator&gt;(const string &amp; lhs, const string &amp; rhs);
bool operator&lt;(const string &amp; lhs, const string &amp; rhs);
bool operator&gt;=(const string &amp; lhs, const string &amp; rhs);
bool operator&lt;=(const string &amp; lhs, const string &amp; rhs);

// 10. 搜索与查找

// find 系列：
size_type find(const basic_string &amp; str, size_type pos = 0) const;
size_type find(const CharT* s, size_type pos = 0) const;
size_type find(const CharT* s, size_type pos, size_type count) const;
size_type find(char ch, size_type pos = npos ) const;
// rfind 系列：
size_type rfind(const basic_string &amp; str, size_type pos = 0) const;
size_type rfind(const CharT* s, size_type pos = 0) const;
size_type rfind(const CharT* s, size_type pos, size_type count) const;
size_type rfind(char ch, size_type pos = npos) const;
</code></pre>
<h3 id="程序内存分配方式">程序内存分配方式</h3>
<pre><code class="language-c++">// 从高到低：内核空间 --&gt; 栈（向下增长） --&gt; 内存映射区（文件映射、动态库、匿名映射） --&gt; 堆（向上增长） --&gt; 数据段（全局、静态） --&gt; 代码段（可执行代码、只读常量）

int globalVar = 1; // 全局变量，位于数据段
static int globalStaticVar = 1; // 静态变量，位于数据段

void test(){
	int funcVar; // 局部变量，位于栈
	static int funcStaticVar; // 局部静态变量，位于数据段，函数退栈时不会被清理
	char* str = &quot;hello&quot;; // str --&gt; 栈  &quot;hello&quot; --&gt; 代码段
	int* ptr = (int* )malloc(sizeof(int)); // 指针存于栈，指向的内存区域位于堆
}
</code></pre>
<h3 id="类和对象">类和对象</h3>
<pre><code class="language-c++">// 1. 类的定义
// C++ 用类来描述对象，类是对现实世界中相似事物的抽象
// 类的定义分为数据（属性）和对数据的操作（行为），可理解为：类是数据类型，对象是类的变量

class 类名
{
public:
	//公有数据成员和成员函数（对外提供的接口、功能、服务）
protected:
	//保护数据成员和成员函数
private:
	//私有数据成员和成员函数：只能在类内部访问
};

// 在类中定义的成员函数均为 inline 函数，可以在类的内部和外部实现，在类的外部实现时应使用作用域限定符 (::) 标识函数所属的类

// 2. class 与 struct 的区别
// C++ 中对 struct 的功能做了拓展，它与 class 的唯一区别是默认访问权限：struct 的默认访问权限是 public, class 的默认访问权限是 private

// 3. 对象的创建
// C++ 在类中使用构造函数来创建对象，它的函数名与类名相同，但无返回值和返回类型
// 构造函数在对象创建时自动调用，以完成对象成员变量的初始化和指针成员的动态内存申请等工作
// 自动生成的构造函数是没有参数的，可自行添加构造函数的参数使创建对象更为方便

class Point
{
public:
	// 不自定义构造函数时，编译器会自动提供，一旦提供带参数的构造函数便不可使用默认构造函数，除非手动写入了默认的构造函数
    Point()
    {
        cout &lt;&lt; &quot;Point()&quot; &lt;&lt; endl;
        _ix = 0;
        _iy = 0;
    }
    Point(int x, int y)
    {
        cout &lt;&lt; &quot;Point()&quot; &lt;&lt; endl;
        _ix = x;
        _iy = y;
    }
    void print()
    {
        cout &lt;&lt; &quot;(&quot; &lt;&lt; _ix &lt;&lt; &quot;,&quot; &lt;&lt; _iy &lt;&lt; &quot;)&quot; &lt;&lt; endl;
    }
private:
	int _ix;
	int _iy;
};

// 4. 初始化列表
// 除通过构造函数初始化数据成员，还可通过初始化列表完成
// 初始化列表位于构造函数形参列表之后，函数体之前，用 : 开始，如果有多个数据成员，再用逗号分隔，初始值放在一对小括号中

class Point
{
public:
    Point(int ix = 0, int iy = 0) : _ix(ix), _iy(iy) // 顺序由成员变量的声明顺序决定
    {
    	cout &lt;&lt; &quot;Point(int = 0,int = 0)&quot; &lt;&lt; endl;
    }

private:
	int _ix;
	int _iy;
};

// 5. 对象的销毁
// 对象被撤销时，自动调用析构函数 (Destructor)
// 析构函数与类同名，在之前冠以 ~ 以区别于构造函数；它没有返回类型，不能指定参数，因此无法被重载，起到清理资源的作用
/* 析构函数的使用场景：
(1) 全局定义的对象，程序结束时自动调用析构函数
(2) 局部定义的对象，程序离开局部对象作用域时调用析构函数
(3) static 定义的静态局部变量，程序结束时调用析构函数
(4) new 创建的对象，用 delete 删除该对象时调用析构函数 */

class Computer
{
public:
    Computer(const char *brand, double price)
    : _brand(new char[strlen(brand) + 1]())
    , _price(price)
    {
    	cout &lt;&lt; &quot;Computer(const char *, double)&quot; &lt;&lt; endl;
    }
    ~Computer()
    {
        cout &lt;&lt; &quot;~Computer()&quot; &lt;&lt; endl;
        delete [] _brand;
        _brand = nullptr;
    }
private:
    char *_brand;
    double _price;
};

// 6. 拷贝构造函数
// 想要实现 Computer com1; Computer com2 = com1; 的效果，就必然涉及对象的创建，此处会调用拷贝构造函数完成创建连带拷贝的操作
// 缺省的拷贝构造函数的原型是：类名::类名(const 类名 &amp;)
// 此处 const 和 &amp; 均不可少，如无 const 将无法绑定临时对象（右值），如无 &amp; 将产生无限递归调用拷贝构造函数的现象
/* 拷贝构造函数的使用场景：
(1) 函数返回值是对象时，函数调用完成返回时会调用拷贝构造函数
(2) 函数的参数是对象，实参和形参结合时会调用拷贝构造函数（值传递）
(3) 用一个已经存在的对象初始化另一个对象时会调用拷贝构造函数 */

Computer::Computer(const Computer &amp;rhs) : _brand(rhs._brand), _price(rhs._price)
{
    // 浅拷贝：只拷贝了地址指针，即两个对象的数据成员指向同一个堆空间的字符串
}

Computer::Computer(const Computer &amp;rhs) : _brand(new char[strlen(rhs._brand)+1]()), _price(rhs._price)
{
    // 深拷贝：两个对象拥有各自独立的堆空间字符串，一个对象销毁时不会影响另一个对象
    strcpy(_brand, rhs._brand);
}


// 7. 隐含的 this 指针
// 类中定义的非静态成员函数中都有一个隐含的 this 指针作为成员函数的第一个参数

void Point::print()
{
	cout &lt;&lt; &quot;(&quot; &lt;&lt; _ix &lt;&lt; &quot;,&quot; &lt;&lt; _iy &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}

void Point::print(Point *const this)
{
	cout &lt;&lt; &quot;(&quot; &lt;&lt; this-&gt;_ix &lt;&lt; &quot;,&quot; &lt;&lt; this-&gt;_iy &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}

// 8. 赋值运算符函数
// 要实现 Computer com1(&quot;Xiaomi&quot;, 7999), com2(&quot;HP&quot;, 13999); com1 = com2; 的效果，流程上应重载运算符，此时在类的创建过程中已经提供了缺省的赋值运算符函数

// com1 = com2; &lt;===&gt; com1.operator=(com2);
Computer &amp;Computer::operator=(const Computer &amp;rhs)
{
    _brand = rhs._brand; // 缺省的赋值运算符函数使用浅拷贝的方式拷贝字符串
    _price = rhs._price; 
    return *this;
}

// 自定义赋值运算符函数：使用深拷贝方式拷贝字符串
Computer &amp;Computer::operator=(const Computer &amp;rhs)
{
    if(this != &amp;rhs){ // 自复制的判断
		delete [] _brand; // 释放左值空间
		_brand = nullptr;
		_brand = new char[strlen(rhs._brand) + 1]();
		strcpy(_brand, rhs._brand); // 深拷贝
		_price = rhs._price;	
    }
	return *this; // 返回 *this
}
// 三合成原则：析构函数、拷贝构造函数、赋值运算符函数如有一个需要显式定义，则其余二者也必须显式定义

// 9. 常量成员、引用成员、类对象成员和静态成员
// (1) 常量数据成员（数据成员用 const 修饰），引用数据成员
// 只能通过构造函数初始化列表来初始化常量数据成员和引用数据成员，在构造函数体内将其初始化是非法的
class Point
{
public:
	// Point() = default; // 合法，表示采用默认的无参构造函数
    Point(int ix = 0, int iy = 0)
	: _ix(ix)
	, _iy(iy)
	, _iz(_ix)
	{
		_ix = ix; // 错误
	}
private:
    const int _ix;
    // const int _ix = 10; // C++ 11 后合法
    const int _iy;
    int &amp; _iz;
};

// (2) 类对象成员
// 只能通过构造函数初始化列表来初始化类对象成员，否则会自动调用该类的默认构造函数，可能与预期结果产生差异

class Line
{
public:
    Line(int x1, int y1, int x2, int y2)
    : _pt1(x1, y1)
    , _pt2(x2, y2)
    {
        cout &lt;&lt; &quot;Line(int,int,int,int)&quot; &lt;&lt; endl;
    }
private:
    Point _pt1;
    Point _pt2;
};

// (3) 静态数据成员
// 对象在运行时被创建，而静态数据成员在编译时就被创建并初始化，且被所有该类的对象共享，它存储在全局（静态）区，不占据对象的存储空间，只能在类的外部被初始化

static double _totalPrice; // 仅声明
double Computer::_totalPrice = 0;

// 10. 静态成员函数和 const 成员函数
// (1) 静态成员函数：只能调用静态数据成员和静态成员函数
// 原因：静态成员函数的参数中不再有隐含的 this 指针，因此可直接使用类名::静态成员函数名的形式对静态成员函数进行调用

class NullPointCall
{
public:
    static void test1();
    void test2();
    void test3(int test);
    void test4();
private:
    static int _static;
    int _test;
};

int NullPointCall::_static = 0;

void NullPointCall::test1()
{
    cout &lt;&lt; &quot;_static = &quot; &lt;&lt; _static &lt;&lt; endl;
}
void NullPointCall::test2()
{
    cout &lt;&lt; &quot;coding is very cool!&quot; &lt;&lt; endl;
}
void NullPointCall::test3(int test)
{
    cout &lt;&lt; &quot;test = &quot; &lt;&lt; test &lt;&lt; endl; 
}
void NullPointCall::test4()
{
    cout &lt;&lt; &quot;_test = &quot; &lt;&lt; _test &lt;&lt; endl; 
}
int main(void)
{
    NullPointCall * pNull = nullptr;
    pNull-&gt;test1(); // correct, _static = 0
    pNull-&gt;test2(); // correct, coding is very cool!
    pNull-&gt;test3(10); // correct, test = 10
    pNull-&gt;test4(); // Segmentation fault, pNull = nullptr
    return 0;
}

// (2) const 成员函数：只能读取对象数据成员而不能修改
// 原理：将原有的 Element * const this 指针参数改为 const Element * const this

void print() const // 不修改数据成员的成员函数需被设为 const 类型
{
	cout &lt;&lt; &quot;品牌:&quot; &lt;&lt; _brand &lt;&lt; endl &lt;&lt; &quot;价格:&quot; &lt;&lt; _price &lt;&lt; endl;
}

// 11. 对象的组织
// (1) const 对象
// 能作用于 const 对象的成员函数只有构造函数，析构函数和 const 成员函数

const Point pt(1, 2);

// (2) 指向对象的指针
// 与普通指针占据大小保持一致，基本格式为：类名* 指针名 [=初始化表达式];

Point pt(1, 2);
Point* p1 = nullptr;
Point* p2 = &amp;pt;
Point* p3 = new Point(3, 4);
Point* p4 = new Point[5];
p3-&gt;print(); // 合法
(*p3).print(); // 合法

// (3) 对象数组
// 与普通数组使用方法一致，分声明、初始化、使用三个步骤

Point pts[2] = {Point(1, 2), Point(3, 4)};
Point pts[] = {Point(1, 2), Point(3, 4)};
Point pts[5] = {Point(1, 2), Point(3, 4)};
// 或者
Point pts[2] = {{1, 2}, {3, 4}};//这里需要注意，除了去掉Point，还换了大括号
Point pts[] = {{1, 2}, {3, 4}};
Point pts[5] = {{1, 2}, {3, 4}};

// (4) 堆对象
// 使用 new 和 delete 为对象在堆空间分配动态存储区
// 为对象数组分配动态空间时不能显式调用对象的构造函数，对象应不定义任何形式的构造函数（使用缺省构造函数），或显式定义一个所有参数都有缺省值的构造函数

Point* pt1 = new Point(11, 12);
delete pt1; pt1 = nullptr;
Point* pt2 = new Point[5]();
delete [] pt2; // 不能使用 free 释放堆空间，因 free 只能释放指针本身而忽略了数据成员

// explicit: 关键字，指定构造函数或转换函数禁止隐式转换

// 12. 单例模式
// 需求：一个类在内存中只能创建一个对象，且该对象是唯一的
// 实现步骤：私有化构造函数 --&gt; 在类中定义一个指向本类型的静态指针变量 --&gt; 定义一个返回值为类指针的静态成员函数
/* 使用场景：
(1) 单例对象替换全局对象
(2) 配置文件信息可以设计为单例对象
(3) 业务场景，如词典
*/
</code></pre>
<h2 id="c-day03"><code>C++ Day03</code></h2>
<h3 id="new和delete表达式在面向对象中的应用"><code>new</code>和<code>delete</code>表达式在面向对象中的应用</h3>
<pre><code class="language-c++">// 1. new 和 delete 的工作步骤
// new 的工作流程：
// 调用 operator new 标准库函数并分配足够大的未初始化的内存以保存指定类型的对象 --&gt; 运行该类型的构造函数来初始化对象 --&gt; 返回指向新构造对象的指针
// delete 的工作流程：
// 调用析构函数，回收对象中数据成员申请的资源 --&gt; 调用 operator delete 标准库函数释放该对象使用的内存

// 2. 选择创建对象的区域
// 要求一个类只能创建栈对象时，需将 operator new/delete 放入 private 区域
// 要求一个类只能创建堆对象时，需将析构函数放入 private 区域，此时要回收堆对象需借助自行定义成员函数解决
</code></pre>
<h3 id="输入输出流">输入输出流</h3>
<pre><code class="language-c++">// 1. C++ 输入输出机制
// (1) 常用流类型
// C++ 的 I/O 发生在流中，流是字节序列，因而 I/O 操作可看作从程序移进或移出字节
// 标准 I/O: 对系统指定的标准设备的输入和输出。即从键盘输入数据，输出到显示器屏幕
// 文件 I/O: 以磁盘文件为对象进行输入和输出，即从磁盘文件输入数据，数据输出到磁盘文件
// 串 I/O: 对内存中指定的空间进行输入和输出，通常指定一个字符数组作为存储空间（实际上可以利用该空间存储任何信息）
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">类名</th>
<th>作用</th>
<th style="text-align:center">头文件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>ios_base</code></td>
<td>抽象基类，管理格式化标志和输入/输出异常</td>
<td style="text-align:center"><code>iostream</code></td>
</tr>
<tr>
<td style="text-align:center"><code>ios</code></td>
<td>抽象基类，管理任意流缓冲</td>
<td style="text-align:center"><code>iostream</code></td>
</tr>
<tr>
<td style="text-align:center"><code>istream, ostream, iostream</code></td>
<td>通用输入流，输出流，输入输出流</td>
<td style="text-align:center"><code>iostream</code></td>
</tr>
<tr>
<td style="text-align:center"><code>ifstream, ofstream, fstream</code></td>
<td>文件输入流，输出流，输入输出流</td>
<td style="text-align:center"><code>fstream</code></td>
</tr>
<tr>
<td style="text-align:center"><code>istringstream, ostringstream, stringstream</code></td>
<td>字符串输入流，输出流，输入输出流</td>
<td style="text-align:center"><code>sstream</code></td>
</tr>
</tbody>
</table>
<pre><code class="language-c++">/* ios 是抽象基类，istream 和 ostream 类由此派生；iostream 类从这二者通过多重继承派生而来，它支持输入输出操作，而 ifstream, ofstream, fstream 分别继承自 istream, ostream, iostream */

// (2) 流的状态
// C++ 标准库用 iostate 表示流的状态，均定义在 ios_base 类中：
// badbit: 系统级的错误，流无法继续使用
// failbit: 可恢复的错误，流可以继续使用
// eofbit: 到达流的末尾时被置位，此时 failbit 也会被置位
// goodbit: 未发生错误，流有效时才能正常使用
// C++ 标准库定义了成员函数来读取以上的标志位：
bool bad() const; // 若流的 badbit 置位，则返回 true; 否则返回 false
bool fail() const; // 若流的 failbit 或 badbit 置位，则返回 true;
bool eof() const; // 若流的 eofbit 置位，则返回 true;
bool good() const; // 若流处于有效状态，则返回 true;
iostate rdstate() const; // 获取流的状态
void setstate(iostate state); // 设置流的状态
void clear(std::ios_base::iostate state = std::ios_base::goodbit); // 重置流的状态

// (3) 流的通用操作
int_type get(); // 读取一个字符
istream &amp; get(char_type &amp; ch); // 读取一行数据
istream &amp; getline(char_type * s, std::streamsize count, char_type delim
='\n'); // 读取 count 个字节的数据
istream &amp; read(char_type * s, std::streamsize count); // 最多获取 count 个字节，返回值为实际获取的字节数
std::streamsize readsome(char_type * s, std::streamsize count);
// 读取到前 count 个字符或在读这 count 个字符进程中遇到 delim 字符就停止，并把读取的这些东西丢掉
istream &amp; ignore(std::streamsize count = 1, int_type delim = Traits::eof());
// 查看输入流中的下一个字符, 但是并不将该字符从输入流中取走，不会跳过输入流中的空格、回车符; 在输入流已经结束的情况下，返回 EOF
int_type peek(); // 获取当前流中游标所在的位置
pos_type tellg();// 偏移游标的位置
basic_istream &amp; seekg(pos_type pos);
basic_istream &amp; seekg(off_type off, std::ios::seekdir dir);
ostream &amp; put(char_type ch); // 往输出流中写入一个字符
ostream &amp; write(const char_type * s, std::streamsize count); //往输出流中写入 count 个字符
pos_type tellp(); // 获取当前流中游标所在的位置
ostream &amp; flush(); // 刷新缓冲区
ostream &amp; seekp(pos_type pos); // 偏移游标的位置
ostream &amp; seekp(off_type off, std::ios_base::seekdir dir);

// 清空缓冲区的流程：clear --&gt; ignore

// (4) 缓冲区（缓存）
// 缓冲区：内存空间的一部分，内存空间中预留了一定的空间用来缓冲输入或输出的数据
// 缓冲区存在的意义：减少磁盘读写次数，提高计算机运行速度

// 缓冲区分为：全缓冲、行缓冲和不带缓冲
// 全缓冲：填满标准 I/O 缓存后才进行实际 I/O 操作（读写磁盘文件）
// 行缓冲：输入输出中遇到换行符时执行实际 I/O 操作（键盘输入数据 / cout）
// 不带缓冲：不进行缓冲操作（标准出错 cerr/stderr）

// C++ 中流的缓冲区基类定义在 streambuf 中，ios 继承了 ios_base 后提供了与 streambuf 的接口，且允许多个 ios 对象绑定同一个 streambuf 对象
streambuf *rdbuf() const; // 返回与之关联的 streambuf; 如果没有，则返回 nullptr
streambuf *rdbuf(streambuf * sb); // 重新设置 streambuf: 如果已被绑定，与先前绑定的 streambuf 解绑，再绑定传入的 streambuf; 如果传入的是 nullptr, 则流对象不与任何缓冲区对象绑定

// 2. C++ 标准 IO
// (1) 标准输入流
// istream 类定义一个输入流对象 cin 代表标准输入，通过流提取符 &gt;&gt; 从流中获取数据，通常会跳过空格、tab、换行键等空白字符，只有在输入完数据再按回车键后该行数据才被送入键盘缓冲区
// (2) 标准输出流
// ostream 类定义三个全局输出流对象：cout, cerr, clog
// cout 将数据输出到终端，与标准 C 输出 stdout 关联
// cerr, clog 是标准错误流，cerr 带有缓冲区而 clog 没有，由此可知 clog 属于全缓冲类型
// (3) 输出缓冲区
// 输出缓冲区刷新的条件：
// 1) 程序正常结束，收尾操作中包含清空缓冲区
// 2) 缓冲区满
// 3) 显式刷新输出缓冲区：endl, flush 等
// 4) 使用 unitbuf 操纵符设置流的内部状态
// 5) 输入流与输出流关联时，读输入流将刷新关联的输出流的输出缓冲区

// 3. C++ 文件 IO
// C++ 的文件操作流有：ifstream, ofstream, fstream

ifstream();
explicit ifstream(const char *filename, openmode mode = in);
explicit ifstream(const string &amp;filename, openmode mode = in);
ofstream();
explicit ofstream(const char *filename, openmode mode = out);
explicit ofstream(const string &amp;filename, openmode mode = out);
fstream();
explicit fstream(const char *filename, openmode mode = in|out);
explicit fstream(const string &amp;filename, openmode mode = in|out);

/* in: 输入，文件将允许做读操作；如果文件不存在，打开失败
out: 输出，文件将允许做写操作；如果文件不存在，则直接创建一个
app: 追加，写入将始终发生在文件的末尾
ate: 末尾，读操作始终发生在文件的末尾
trunc: 截断，如果打开的文件存在，其内容将被丢弃，其大小被截断为零
binary: 二进制，读取或写入文件的数据为二进制形式

文件指针的偏移：
ios_base::beg: 文件开头
ios_base::cur: 当前指针位置
ios_base::end: 文件结尾位置
*/

// 4. C++ 字符串 IO
// 字符串流也叫内存流，是以内存中的字符串类对象或字符数组为输入输出对象的数据流
// C++ 字符串操作流有：istringstream, ostringstream, stringstream

istringstream(): istringstream(ios_base::in)
{
    
}
explicit istringstream(openmode mode = ios_base::in);
explicit istringstream(const string&amp; str, openmode mode = ios_base::in);

ostringstream(): ostringstream(ios_base::out)
{
    
}
explicit ostringstream(openmode mode = ios_base::out);
explicit ostringstream(const string&amp; str, openmode mode = ios_base::out);

stringstream(): stringstream(in|out)
{
    
}
explicit stringstream(openmode mode = ios_base::in|ios_base::out);
explicit stringstream(const string&amp; str, openmode mode = ios_base::in|ios_base::out);

</code></pre>
<h2 id="c-day04"><code>C++ Day04</code></h2>
<h3 id="日志系统">日志系统</h3>
<pre><code class="language-c++">// 1. 设计日志系统
// 日志优先级、日志来源、日志布局、日志目的地

// 2. log4cpp
// (1) 日志记录器（来源）：log4cpp::Category
// 可以设置多个 Appender, 每个 Appender 都需要设置各自的 Layout

// (2) 日志优先级：log4cpp::Priority
// 每个 Category 都有一个日志优先级，且每条日志也可设置其优先级
// 记录原则：每条日志的优先级 &gt;= Category 的优先级，日志被输出

// (3) 日志布局：log4cpp::Layout
// BasicLayout: 默认格式
// PatternLayout: 自定义格式

// (4) 日志目的地：log4cpp::Appender
// OstreamAppender: C++ 标准输出流 (ostream --&gt; cout)
// FileAppender: C++ 文件流 (fstream)
// RollingFileAppender: 回卷文件 ——— 分多个文件保存日志信息，并将最新日志保存在最早的文件中
</code></pre>
<h2 id="c-day05"><code>C++ Day05</code></h2>
<h3 id="运算符重载">运算符重载</h3>
<pre><code class="language-c++">/* 1. 友元 */
// 将其他类或函数设置为类的友元时，类的私有成员可以被其他类或函数访问
// 友元的声明不受 public/protected/private 限制，且是单向不可继承的

class 类名
{
//...
friend 函数原型; // 此函数可以访问当前类中的私有成员
friend class 类名; // 此类中的成员函数可以访问当前类中的私有成员
//...
}

/* 2. 运算符重载 */
// 本质：函数重载、函数多态（用同名的函数完成不同的基本操作）

// 运算符函数
返回类型 operator 运算符(参数表)
{
//...
}
// 不可重载的运算符：.  .*(成员指针)  ?:(三目运算符)  ::  sizeof

/* 运算符重载的规则 */
// (1) 重载运算符的操作对象至少有一个是自定义或枚举类型
// (2) 重载运算符不会改变运算符的用法，且其优先级、结合性等属性保持不变
// (3) 重载运算符函数不能有默认参数
// (4) 重载逻辑运算符 (&amp;&amp;, ||) 后不再具备短路求值的特性
// (5) 不能自创不存在的运算符
/* 运算符重载的形式：普通函数、成员函数、友元函数 */
// (1) 普通函数
// 需要利用成员函数获取私有成员的值后再重载运算符函数
// (2) 成员函数、友元函数
// 无需利用成员函数获取私有成员的值，可以直接使用；使用 friend 关键字在类中声明友元函数即可在类外定义无需类名的运算符函数

/* 3. 特殊运算符的重载 */
// (1) 复合赋值运算符: +=/-= ...
// 对象本身发生了变化，应使用成员函数形式进行运算符重载，这样可以方便地访问类中的私有成员，且返回值可设为隐含的 this 指针
// (2) 自增/自减运算符: ++/--
// C++ 根据参数的个数区分前置和后置自增/自减运算符，使用默认的不带参数的成员函数重载自增/自减运算符时，所得结果为前置；如需得到后置，应为重载函数加上一个 int 类型参数以告知编译器（该参数仅起标记作用，并不传递值）
// 前置自增/自减操作所得结果可以使用取地址符操作，因返回值仍为 this 指针，而后置不可以，因使用了栈空间中的对象保存了 this 中的原值
// (3) 赋值运算符：与构造函数中赋值运算符一致
// (4) 函数调用运算符: ()
// 一个类重载了函数调用 operator() 时，该类的对象可以被作为一个函数使用
// 重载了函数调用运算符的类创建的对象称为函数对象

int class1::operator()(int num)
{
//...
}
class1 obj;
cout &lt;&lt; obj(1) &lt;&lt; endl;

// (5) 下标访问运算符: []
// [] 是一个二元运算符，重载它时只能以成员函数的形式进行
// string 类中重载了下标访问运算符，因而可以像数组一样访问元素

char&amp; class1::operator[](size_t idx)
{
	//...    
}
class1 obj;
cout &lt;&lt; obj[1] &lt;&lt; endl;

// (6) 成员访问运算符: -&gt;, *
// -&gt;, * 只能以成员函数的形式重载，返回值必须是一个指针或重载过 -&gt;, * 的对象
// (7) 输入输出流运算符: &lt;&lt;, &gt;&gt;
// &lt;&lt;, &gt;&gt; 不能重载为成员函数，因其需要左右操作数作为参数，而成员函数隐含有 this 指针
// 可以将重载函数设为友元函数以访问类中的私有成员
/* 运算符重载的形式总结：
1. 所有的一元运算符，建议以成员函数重载
2. 运算符 = () [] -&gt; -&gt;* ，必须以成员函数重载
3. 运算符 += -= /= *= %= ^= &amp;= != &gt;&gt;= &lt;&lt;= 建议以成员函数形式重载
4. 其它二元运算符，建议以友元函数重载
*/

/* 4. 类对象与其他类型的类型转换 */
// (1) 其他类型转换为类对象类型
// 由类的构造函数实现，发生隐式转换时类中必须定义相应的构造函数
// (2) 类对象类型转换为其他类型
// 类对象类型转换为其他类型必须借助类型转换函数

operator [target elemtype]() // 必须是成员函数，且不能有参数
{
    // 没有返回值，但需用 return 返回一个目标类型变量
}

</code></pre>
<h2 id="c-day06"><code>C++ Day06</code></h2>
<h3 id="类作用域">类作用域</h3>
<pre><code class="language-c++">/* 作用域：类作用域、类名的作用域、对象的作用域 */
/* 类定义的作用域：全局作用域、类作用域、块作用域 */

/* 1. 全局作用域 */
// 全局类是在函数和其他类定义外部定义的类，它的作用域是全局作用域

/* 2. 类作用域 */
// 定义在另一个类定义中的类称为嵌套类（内部类）
// 嵌套类的访问权限如果是 public, 则作用域与其外部的类定义相同；如果是 private, 则只能在其外部的类定义内使用类名创建该类的对象
// 应用：
// (1) Pimpl 设计模式
// 核心思想：通过一个私有的成员指针，将指针指向的类内部数据隐藏
// Pimpl 的好处：实现信息隐藏、方便升级库文件（用新库替换旧库）
// (2) 单例模式的自动释放
/*
1) 友元类
额外定义一个类并设其为单例类的友元类，此时该类能够访问单例类内的静态指针并释放
2) 内部类 + 静态数据成员
定义一个内部类，使得在其析构函数中能够访问其外部的类的静态指针并释放
3) atexit
atexit 函数可注册一个函数，使其在 main 函数执行解释后自动执行指定的函数
利用 atexit 的特性，可注册 destroy 函数从而达到程序运行结束后自动释放的效果
多线程模式下，采用懒汉模式 (_psin = nullptr;)
4) pthread_once
pthread_once 函数可注册一个函数，保证其在生命周期中只能执行一次
可用 pthread_once 注册的函数嵌套 atexit(destroy) 使用，还可在该函数中初始化静态指针
*/

/* 3. 块作用域 */
// 局部类是定义在代码块中的类，其作用域局限于所在的块
</code></pre>
<h3 id="string的底层实现"><code>String</code>的底层实现</h3>
<pre><code class="language-c++">/* std::string 包含的基本信息：字符串的大小、能容纳的字符数量、字符串内容 */

/* 1. Eager Copy (深拷贝) */
// 复制操作过多时，效率较低

/* 2. COW (Copy-On-Write) */
// 两个 string 发生复制构造或赋值时，引用计数加 1, 字符串指针进行浅拷贝
// 修改字符串内容时，才执行真正的复制
// string 销毁时，引用计数减 1, 只有引用计数为 0 时才真正释放字符串内容所在空间
// 以自行构造内部类的方式使用 [] 对 string 读或写的操作进行区分

class rOw
{
public:
    rOw(String &amp; str, size_t idx) : _str(str), _idx(idx) {}
    friend ostream &amp; operator&lt;&lt;(ostream &amp; os, const rOw &amp; rhs){
        os &lt;&lt; rhs._str.begin()[rhs._idx];
        return os;
    }
    rOw &amp; operator=(const char &amp; c)
    {
        if(_idx &gt;= 0 &amp;&amp; _idx &lt; _str.size()) {
            if(_str.getRefCount() &gt; 1) {
                _str.decreaseRefCount();
                // eager copy
                char * ptmp = new char[_str.size() + 1 + sizeof(int)]() + sizeof(int);
                strcpy(ptmp, _str._pstr);
                _str._pstr = ptmp;
                _str.initRefCount();
            }
            _str._pstr[_idx] = c;
        }else{
            _str._pstr[_idx] = '\0';
        }
        return *this;
    }
private:
    String &amp; _str;
    size_t _idx;
};

/* 3. SSO (Short String Optimization) */
// 核心思想：字符串的长度小于等于 15 时执行深拷贝，否则执行 COW 策略

class string
{
    union Buffer
    {
        char * _pointer;
        char _local[16];
    };
    Buffer _buffer;
    size_t _size;
    size_t _capacity;
};
</code></pre>
<h2 id="c-day07"><code>C++ Day07</code></h2>
<h3 id="继承">继承</h3>
<pre><code class="language-c++">/* 1. 继承的定义 */
// 通过继承，可以用原有类型定义一个新类型，其既包含原有类型的成员，也能添加新的成员
// 一个派生类继承一个基类时，需要在派生类的类派生列表中明确指出它从哪个基类继承而来

class 派生类
: public/protected/private 基类
{
    /* 派生类的生成过程：
     * 1. 吸收基类的成员
     * 2. 改造基类的成员
     * 3. 添加新成员
     */ 
};

/* 2. 继承的局限 */
/* 不能从基类继承的函数：
 * (1) 构造函数
 * (2) 析构函数
 * (3) 重载的 operator new/delete 运算符
 * (4) 重载的 operator= 运算符
 * (5) 友元关系
 */

/* 3. 派生方式对基类成员的访问权限 */
</code></pre>
<table>
<thead>
<tr>
<th style="text-align:center">继承方式</th>
<th style="text-align:center">基类成员访问权限</th>
<th style="text-align:center">派生类中的访问权限</th>
<th style="text-align:center">派生类对象访问</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">公有继承</td>
<td style="text-align:center"><code>public/protected/private</code></td>
<td style="text-align:center"><code>public/protected/不可直接访问</code></td>
<td style="text-align:center"><code>可直接访问/不可直接访问/不可直接访问</code></td>
</tr>
<tr>
<td style="text-align:center">保护继承</td>
<td style="text-align:center"><code>public/protected/private</code></td>
<td style="text-align:center"><code>protected/protected/不可直接访问</code></td>
<td style="text-align:center"><code>不可直接访问</code></td>
</tr>
<tr>
<td style="text-align:center">私有继承</td>
<td style="text-align:center"><code>public/protected/private</code></td>
<td style="text-align:center"><code>private/private/不可直接访问</code></td>
<td style="text-align:center"><code>不可直接访问</code></td>
</tr>
</tbody>
</table>
<pre><code class="language-c++">/* 派生类的访问权限规则总结
1．不管以什么继承方式，派生类内部都不能访问基类的私有成员
2．不管以什么继承方式，派生类内部除了基类的私有成员不可以访问外，其他的都可以访问
3．不管以什么继承方式，派生类对象除了公有继承基类中的公有成员可以访问外，其他的一律不能访问
*/

/* 4. 派生类对象的构造 */
// 默认的继承方式是私有继承，派生类必须重新定义构造函数和析构函数
// 创建派生类对象时，系统首先通过派生类的构造函数来调用基类的构造函数完成基类成员的初始化，再对新增成员进行初始化

派生类名 (总参数表) : 基类构造函数(参数表)
{
	//...
};

/* 派生类对象构造的四种情况：
1) 派生类有显式定义的构造函数而基类没有
派生类相应的构造函数会被自动调用，此时自动调用了基类缺省的无参构造函数
2) 派生类没有显式定义构造函数而基类有
此时基类必须有默认构造函数
3) 派生类有构造函数且基类有默认构造函数
基类的默认构造函数被自动调用，如想调用基类的有参构造函数，需在派生类的构造函数初始化列表中显式调用
4) 派生类有构造函数但基类只有有参的构造函数
派生类的每个构造函数必须在初始化列表中显式调用基类的某个有参构造函数

总结：必须将基类的构造函数放在派生类的构造函数的初始化列表中
派生类构造函数的调用顺序：
调用派生类构造函数 --&gt; 开辟对象所需内存 --&gt; 调用基类构造函数完成基类成员初始化 --&gt; 如派生类中含有对象成员、const 成员或引用成员，需在初始化列表中完成其初始化 --&gt; 派生类构造函数体执行
*/

/* 5. 派生类对象的销毁 */
// 派生类对象销毁时的调用顺序：（与创建派生类对象的流程相反）
// 派生类的析构函数 --&gt; 派生类中成员对象（如有）的析构函数 --&gt; 基类的析构函数 

/* 6. 多基继承（多基派生） */
// 基本形式：

class 派生类
: public/protected/private 基类 1
, ...
, public/protected/private 基类 N
{
    // 构造和销毁的顺序
    // 构造函数的执行顺序：所有基类的构造函数（顺序：1 ~ N）--&gt; 派生类构造函数中初始化表达式 --&gt; 构造函数体
    // 析构函数的执行顺序与构造函数相反
};

// 成员名冲突的二义性：多个基类中存在同名成员时，需指明调用的是某个基类的成员（使用作用域限定符 ::)
// 菱形继承的二义性：中间的类从父类虚拟继承

/* 7. 基类与派生类间的相互转换 */
/* 派生类适应于基类，具体体现在：
1) 可以把派生类的对象赋值给基类的对象
2) 可以把基类的引用绑定到派生类的对象
3) 可以声明基类的指针指向派生类的对象（向上转型）（向下转型：派生类的指针指向基类对象）
*/

/* 8. 派生类对象间的复制控制 */
// 原则：基类部分和派生类部分是分开进行复制的
/* 派生类对象间执行复制操作时可能出现的情况有：
1) 用户定义了基类的拷贝构造函数而没有定义派生类的拷贝构造函数
执行复制操作时，两对象间的派生类部分执行缺省行为，基类部分执行用户定义的基类拷贝构造函数
2) 用户重载了基类的赋值运算符函数而没有重载派生类的赋值运算符函数
执行复制操作时，两对象间的派生类部分执行缺省赋值行为，基类部分执行用户定义的基类重载赋值函数
3) 用户定义了派生类的拷贝构造函数或重载了派生类的对象赋值运算符 = 
执行复制操作时，将会执行用户定义的派生类的拷贝构造函数或重载赋值函数，不再自动调用基类的拷贝构造函数和基类的重载对象赋值运算符，但派生类的拷贝构造函数或赋值运算符函数中必须显式调用基类的拷贝构造函数或赋值运算符函数
*/
</code></pre>
<h2 id="c-day08"><code>C++ Day08</code></h2>
<h3 id="多态">多态</h3>
<pre><code class="language-c++">/* 多态的核心思想：一个接口，多种方法 */

/* 1. 多态性的分类：编译时多态、运行时多态 */
// 编译时多态（静态多态，先期联编）：编译器根据传递给函数的参数和函数名决定要使用哪个函数（函数重载、运算符重载）
// 运行时多态（动态多态，晚期联编）：编译器无法在编译过程中联编，则必须在程序运行时完成选择（虚函数）

/* 2. 虚函数 */
// 原则：基类中声明为 virtual, 在派生类中被重新定义的成员函数
// 基类中定义为虚函数时，派生类中的 virtual 关键字可以省略

class 类名
{
    virtual 返回类型 函数名(参数表)
    {
        //...
    }
};

/* 派生类中对虚函数重定义的原则：
(1) 与基类的虚函数有相同的参数个数
(2) 与基类的虚函数有相同的参数类型
(3) 与基类的虚函数有相同的返回类型 */
// 虚函数的实现机制：
// 在类中定义一个虚函数后，会在该类创建的对象的存储布局的开始位置多建立一个虚函数指针 (vfptr), 其指向一张虚函数表，表中存放各虚函数的入口地址；派生类对基类中的虚函数重定义时，会覆盖派生类虚函数表中虚函数的入口地址
// 虚函数的激活形式（动态多态的实现过程）：
// 基类定义虚函数 --&gt; 派生类重定义虚函数 --&gt; 创建派生类对象 --&gt; 基类指针指向派生类对象 --&gt; 基类指针调用虚函数
/* 不能设置为虚函数的函数：
(1) 普通函数（非成员函数）：从需求角度来说，没有重写的硬性要求
(2) 静态成员函数：被所有对象共享，因此无需重写（静态函数发生在编译阶段，虚函数动态绑定发生在运行阶段）
(3) 内联成员函数：内联函数在编译时直接展开，虚函数动态绑定发生在运行阶段，无法统一
(4) 构造函数：虚函数对不同类型的对象产生不同的动作，是建立在对象建立的基础之上的
(5) 友元函数：友元函数不属于成员函数，除非在当前类中作为另一个类的友元声明为虚函数，否则不能声明为虚函数 */ 

/* 3. 虚函数的访问 */
// (1) 指针访问
// 使用指针访问虚函数，编译器根据所指对象的类型决定调用哪个函数（动态联编），与指针本身类型无关
// (2) 引用访问
// 使用引用访问虚函数与使用指针访问虚函数类似，引用一经声明不再改变，因此提高了代码的安全性
// (3) 对象访问
// 使用对象名调用虚函数，编译器采用静态联编，通过定义对象名的类型来决定调用函数的所在类
// (4) 成员函数中访问
// 在类内的成员函数中访问该类层次中的虚函数，采用动态联编，要使用 this 指针
// (5) 构造函数和析构函数中访问
// 编译器采用静态联编，在构造函数或析构函数中使用“本类名::虚函数名”的形式调用虚函数，即虚函数是自身所在类中的函数；如自身所在类中没有实现该函数就调用基类中的虚函数

/* 4. 纯虚函数 */
// 定义：在基类中声明一个虚函数，实现留给基类的派生类去做，此时不可用构造函数建立基类的对象

class 类名
{
public:
	virtual 返回类型 函数名(参数包) = 0;
};

/* 5. 抽象类 */
// 含有至少一个纯虚函数的类称为抽象类，该类只能作为基类来派生新的类，不能创建抽象类的对象；如派生类没有对所有的纯虚函数进行重定义，该类也将称为抽象类
// 对一个类，如只定义了 protected 类型的构造函数而没有 public 类型的构造函数，将成为一个能派生新类但不能创建自己的对象的抽象类

/* 6. 虚析构函数 */
// 一般地，如果类中定义了虚函数，析构函数也应被定义为虚析构函数，尤其是类中有动态申请内存的情况出现时
// 如将基类指针指向一个派生类对象，则基类的析构函数需设为虚函数以避免不执行派生类的析构函数导致的内存泄漏，此时派生类的析构函数也被自动设为了虚函数
// 强制转换的解决方案：使用 dynamic_cast 将基类对象强制转换为对应类型的对象指针

/* 7. 重载、隐藏、覆盖 */
// 重载：发生在同一作用域内，函数名称相同，参数列表不同
// 覆盖：发生在基类与派生类中，同名虚函数的参数列表完全相同
// 隐藏：发生在基类与派生类中，指派生类的函数屏蔽了基类的同名函数或同名数据成员，调用基类方法或数据成员需加 ::

/* 8. 带虚函数的多重继承 */
// 每个基类都有自己的虚函数表，派生类如有自己的虚函数，会被加入到第一个虚函数表中
// 基类的内存布局按照基类声明的顺序进行排列，派生类会覆盖基类的虚函数，只有第一个虚函数表中存放的是真实的被覆盖的函数地址，其他的虚函数表中存放的是跳转指令

/* 9. 多基派生的二义性 */
// 多个基类内相同的虚函数被派生类调用时会产生二义性，此时用 :: 指明函数来自于哪个基类即可

/* 10. 虚拟继承 */
// 虚拟继承：在继承定义中包含了 virtual 关键字的继承关系
// 虚基类：在虚继承体系中通过 virtual 继承而来的基类
/* 虚拟继承对应虚函数的三大特征：存在、间接、共享
(1) 虚函数是真实存在的 --&gt; 虚继承体系和虚基类是真实存在的
(2) 虚函数必须通过间接的运行时机制才能被激活 --&gt; 访问虚基类成员时必须通过间接机制完成（虚基表）
(3) 基类共享被派生类重定义后的虚函数 --&gt; 虚基类在虚继承体系中被共享，不会出现多份拷贝 */

class Baseclass;
class Subclass // Baseclass 是 Subclass 的虚基类
: public/private/protected virtual Baseclass
{
public:
	//...
private:
	//...
protected:
	//...
};

/* 虚拟继承的两个重要结论：
(1) 不带虚函数的单个虚继承：虚继承比继承多一个虚基指针，虚基类位于派生类存储空间的末尾
(2) 带虚函数的单个虚继承：派生类没有自己的虚函数就不会产生虚函数指针，否则产生本身的徐函数指针位于派生类对象存储空间的开始位置 */

// (1) 虚拟继承中派生类对象的构造和析构
// 继承链上存在虚继承的基类时，最底层的子类要负责完成该虚基类部分成员的构造（显式调用虚基类的构造函数完成初始化），如不显式调用则调用缺省构造函数，此时若虚基类中没有定义的缺省构造函数会发生编译错误

// (2) 菱形继承
/* 虚基指针指向虚基表：
1. 虚基指针的第一条内容：虚基指针距离所在子对象的首地址的偏移
2. 虚基指针的第二条内容：虚基指针距离虚基类子对象的首地址的偏移 */


</code></pre>
<h2 id="c-day09"><code>C++ Day09</code></h2>
<h3 id="模板">模板</h3>
<pre><code class="language-c++">/* 1. 模板的定义 */

template &lt;class T, ...&gt; // 参数列表不能为空
template &lt;typename T, ...&gt;
    
/* 2. 模板的类型 */
// (1) 函数模板                                                        

/*
          模板参数推导（时机：编译阶段，实参传递时）
函数模板 &lt;---------------------------------------&gt; 模板函数
                          实例化
*/
template &lt;class T&gt;
T add(T x, T y) // 不能分成头文件和实现文件，否则无法通过编译
{
    cout &lt;&lt; &quot;T add(T, T)&quot; &lt;&lt; endl;
    return x + y;
}
cout &lt;&lt; &quot;add(ia, ib) = &quot; &lt;&lt; add(ia, ib) &lt;&lt; endl; // 隐式实例化，需编译器推导
cout &lt;&lt; &quot;add(ia, ib) = &quot; &lt;&lt; add&lt;double&gt;(ia, ib) &lt;&lt; endl; // 显式实例化

/* 函数模板与普通函数的关系：
(1) 函数模板和普通函数、函数模板和函数模板之间可以进行重载
(2) 普通函数优先于函数模板执行 
(3) 模板不能将声明与实现分开，普通函数可以 */
/* 函数模板的参数类型：
(1) 类型参数：class T/typename T = int
(2) 非类型参数：整型常量表达式 (bool/char/short/int/long/size_t)
(3) 类的成员函数也可以设为模板 */

// (2) 类模板
// 与函数模板的使用方法类似，且可以嵌套函数模板或类模板

/* 3. 可变模板参数 */
// C++11 的特性之一，能够表示 0 到任意个数、任意类型的参数

// (1) 模板参数包
template&lt;typename ...Args&gt; // sizeof... 运算符：获取参数包中的参数个数  
class tuple; // tuple 是元组的意思，其模板参数就是模板参数包
// Args（模板参数包）表示可以接受任意多个参数作为模板参数，此时编译器将多个模板打包，可以将参数包展开成一个一个独立的参数
// ... 位于参数右边时称为解包

// (2) 函数参数包
template&lt;typename ...T&gt; 
void f(T ...args); // args 函数参数包
// args（函数参数包）表示函数可接受多个任意类型的参数
// 函数参数包必须唯一且为函数最后一个参数，使用参数包时省略号位于参数名称的右侧，表示解包
</code></pre>
<h2 id="c-day10"><code>C++ Day10</code></h2>
<h3 id="移动语义">移动语义</h3>
<pre><code class="language-c++">/* 1. 左值、右值、const 左值引用、右值引用 */
// 可以取地址的称为左值，否则称为右值；右值可能存储在寄存器或栈上，包括临时对象、匿名对象、字面值常量等
// 左值引用不能绑定到右值，右值引用不能绑定到左值
// const 左值引用可以绑定到左值或右值
// 右值引用既可以是左值（移动赋值函数的参数）也可以是右值（函数返回类型）

/* 2. 移动构造函数和移动赋值运算符函数 */
// 移动构造函数和移动赋值运算符函数识别右值并处理，其优先级高于拷贝构造函数
// 具有移动语义的函数必须手动书写，编译器不会自动生成

String(String&amp;&amp; rhs)
: _pstr(rhs._pstr)
{
    cout &lt;&lt; &quot;String(String &amp;&amp;)&quot; &lt;&lt; endl;
    rhs._pstr = nullptr;
}

String &amp;operator=(String&amp;&amp; rhs)
{
	if(this != &amp;rhs){
		delete [] _pstr;
		_pstr = nullptr;
		_pstr = rhs._pstr;
		rhs._pstr = nullptr;
    }
	return *this;
}

/* 3. std::move */
// 作用：将左值转换为右值，表明不想使用该值；可通过重新赋值来继续使用该值
// 本质：使用 static_cast&lt;T &amp;&amp;&gt;(lvalue) 做强制转换
</code></pre>
<h3 id="资源管理与智能指针">资源管理与智能指针</h3>
<pre><code class="language-c++">/* 1. RAII 技术 */
// RAII 技术利用对象离开作用域时自动调用析构函数的特性管理程序资源，保证资源的释放顺序与获取顺序严格相反
/* RAII 的一般特征：
(1) 构造时初始化资源，析构时释放资源，并提供若干访问资源的方法
(2) 不允许赋值或复制，不提供拷贝构造函数和赋值运算符函数 */

RAII(const RAII &amp;rhs) = delete;
RAII &amp;operator=(const RAII &amp;rhs) = delete;

private:
RAII(const RAII &amp;rhs);
RAII &amp;operator=(const RAII &amp;rhs);

/* 2. 四种智能指针 */
// (1) auto_ptr: 有缺陷的智能指针，C++17 已经删除

int* pInt = new int(10);
auto_ptr&lt;int&gt; ap(pInt);
auto_ptr&lt;int&gt; ap2(ap); // 调用拷贝构造函数
auto_ptr(auto_ptr&amp; __a) 
: _M_ptr(__a.release()) // 释放 ap, 所有权发生了变更，因此不能对 ap 解引用
{
    
}

// (2) unique_ptr: 独享所有权的智能指针
// unique_ptr 独享资源的所有权，不能进行复制、赋值操作
// 具有移动语义，可以通过 std::move 移动语义转移原指针的所有权
// 可以作为容器的元素 --&gt; 只能传右值

unique_ptr&lt;int&gt; up(new int(10));
unique_ptr&lt;int&gt; up2(up); // 错误，不能进行复制操作
unique_ptr&lt;int&gt; up3 = up; // 错误，不能进行赋值操作
unique_ptr&lt;int&gt; up4(move(up)); // 通过移动语义转移 up 的所有权

// (3) shared_ptr: 共享所有权的智能指针
// shared_ptr 采用类似写时复制 COW 的原理，利用浅拷贝 + 引用计数达到共享所有权的效果
// enable_shared_from_this: 返回一个与 this 指针共享所有权的 shared_ptr, 通过 shared_from_this() 得到该智能指针，此时不会出现两个 shared_ptr 共同指向同一堆空间的 double free 问题

shared_ptr&lt;int&gt; sp(new int(10));
shared_ptr&lt;int&gt; sp2(sp);

// (4) weak_ptr: 解决 shared_ptr 中存在的循环引用问题
// 循环引用：两个 shared_ptr 互指，导致引用计数增加，对象销毁时引用计数无法减为 0 导致出现内存泄漏的现象
// weak_ptr 不会导致引用计数增加，获取资源时必须通过 lock 函数转为 shared_ptr
// 通过从 weak_ptr 能否转为 shared_ptr 来判断共享资源是否已经销毁

/* 3. 智能指针的定制删除器 */
// 自定义智能指针的方式：函数指针、仿函数（函数对象）

// 仿函数：重载函数调用运算符 operator()
struct FILECloser
{
    void operator()(FILE* fp) const{
        if(fp){
            fclose(fp);
            cout &lt;&lt; &quot;fclose(fp)&quot; &lt;&lt; endl;
        }
    }
};

// 函数指针
void FILECloser(FILE* fp){
    if(fp){
        fclose(fp);
        cout &lt;&lt; &quot;fclose(fp)&quot; &lt;&lt; endl;
    }
}
</code></pre>
<h2 id="c-day11"><code>C++ Day11</code></h2>
<h3 id="标准模板库stl">标准模板库<code>STL</code></h3>
<pre><code class="language-c++">/* 0. STL 组件 */
// (1) 容器 (container): 实现原理是类模板 (class template), 大致分为三类：序列容器，如 vector, list. deque 等；关联容器，如 set, map等；无序无关联式容器，如 unordered_set, unordered_map 等
// (2) 迭代器 (iterator): 一套访问容器的接口，行为类似于指针；它为不同算法提供的相对统一的容器访问方式，使得设计算法时无需关注过多关注数据
// (3) 算法 (algorithm): 提供一套常用的算法，如 sort, search, copy, erase 等，在实现上，可以认为是一种函数模板 (function template)
// (4) 配置器 (allocator): 为所有的容器提供空间配置和释放，对象构造和析构的服务，也是一个class template
// (5) 函数对象 (functor): 作为函数使用的对象，用于泛化算法中的操作
// (6) 配接器 (adapter): 将一种容器修饰为功能不同的另一种容器，如以容器 vector 为基础，在其上实现 stack, stack 的行为也是一种容器。除此之外，还有迭代器配接器和仿函数配接器。

/* 1. 容器 */
// (1) 序列式容器：vector, deque, list
// 1.1 初始化
// 1.1.1 初始化为空
vector&lt;int&gt; nums;
deque&lt;int&gt; nums;
list&lt;int&gt; nums;

// 1.1.2 初始化为多个数据
vector&lt;int&gt; nums(5, 1);
deque&lt;int&gt; nums(5, 3);
list&lt;int&gt; nums(5); // 如不填则默认初始化为 0

// 1.1.3 使用迭代器范围
int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
vector&lt;int&gt; nums(arr, arr + 10); // 左闭右开：[first, last)

// 1.1.4 通过其他 vector 构造
vector&lt;int&gt; nums(5, 1);
vector&lt;int&gt; nums1(nums);

// 1.1.5 使用大括号
vector&lt;int&gt; nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
deque&lt;int&gt; nums{1, 2, 3, 4};

// 1.2 遍历
// 1.2.1 下标运算符进行遍历：容器必须支持下标访问，如 list 就不支持下标访问
vector&lt;int&gt; nums{1, 2, 3, 4};
for(size_t i = 0;i &lt; nums.size();++i){
    cout &lt;&lt; nums[i] &lt;&lt; &quot; &quot;; // 1 2 3 4
}

// 1.2.2 迭代器进行遍历
vector&lt;int&gt; nums{1, 2, 3, 4};
for(vector&lt;int&gt;::iterator it = nums.begin();it != nums.end();++it){
    cout &lt;&lt; *it &lt;&lt; &quot; &quot;; // 1 2 3 4 
}

// 1.2.3 auto 配合迭代器进行遍历
vector&lt;int&gt; nums{1, 2, 3, 4};
for(auto it = nums.begin();it != nums.end();++it){
    cout &lt;&lt; *it &lt;&lt; &quot; &quot;; // 1 2 3 4
}

// 1.2.4 for + auto
vector&lt;int&gt; nums{1, 2, 3, 4};
for(auto&amp; elem : numbers){
	cout &lt;&lt; elem &lt;&lt; &quot; &quot;; // 1 2 3 4
}

// 1.3 尾部插入与删除：push_back() / pop_back()
// 头部插入与删除：push_front() / pop_front()
</code></pre>
<h3 id="各容器继承关系及底层原理">各容器继承关系及底层原理</h3>
<h3 id="vector"><code>vector</code></h3>
<pre><code class="language-C++">// 2.1 vector
// 2.1.1 push_back() 扩容原理：
// 插入元素时，size == capacity, 无足够空间存放新元素 --&gt; 申请大小为 size * 2 的空间 --&gt; 将原来空间的元素复制到新空间，并释放原来的空间 --&gt; 将新元素放入尾部

const size_type __len = (__old_size != 0) ? 2 * __old_size : 1;

// 2.1.2 vector 的继承关系：
                     public                  protected
_Vector_alloc_base ----------&gt; _Vector_base -----------&gt; vector
        |
        |
        V                 
_Tp* _M_start
_Tp* _M_finish (vector.size() + 1)
_Tp* _M_end_of_storage (vector.capacity() + 1)
sizeof(vector) = 24
                         
// 2.1.3 vector 迭代器：随机存取迭代器 (RandomAccessIterators)
// 由于迭代器的种类特性，vector 支持 sort, merge 等 algorithm 的使用

iterator begin() { return _M_start; }
const_iterator begin() const { return _M_start; }
iterator end() { return _M_finish; }
const_iterator end() const { return _M_finish; }

reverse_iterator rbegin()
{ return reverse_iterator(end()); }
const_reverse_iterator rbegin() const
{ return const_reverse_iterator(end()); }
reverse_iterator rend()
{ return reverse_iterator(begin()); }
const_reverse_iterator rend() const
{ return const_reverse_iterator(begin()); }

size_type size() const
{ return size_type(end() - begin()); }
size_type max_size() const
{ return size_type(-1) / sizeof(_Tp); }
size_type capacity() const
{ return size_type(_M_end_of_storage - begin()); }
bool empty() const
{ return begin() == end(); }

reference operator[](size_type __n) { return *(begin() + __n); } // 没有安全检查
const_reference operator[](size_type __n) const { return *(begin() + __n); }

#ifdef __STL_THROW_RANGE_ERRORS
void _M_range_check(size_type __n) const {
    if (__n &gt;= this-&gt;size())
        __stl_throw_range_error(&quot;vector&quot;);
}

reference at(size_type __n)
{ _M_range_check(__n); return (*this)[__n]; } // at 比 operator[] 更安全
const_reference at(size_type __n) const
{ _M_range_check(__n); return (*this)[__n]; }
#endif /* __STL_THROW_RANGE_ERRORS */

~vector() { destroy(_M_start, _M_finish); }
                         
// 2.1.4 vector 的空间配置器
// vector 缺省使用 alloc 作为空间配置器，并另外定义一个 data_allocator

vector(size_type __n, const value_type&amp; __value, const allocator_type&amp; __a = allocator_type()) : _Base(_S_check_init_len(__n, __a), __a)
{
	_M_fill_initialize(__n, __value); 
}
void _M_fill_initialize(size_type __n, const value_type&amp; __value)
{
	this-&gt;_M_impl._M_finish = 
        std::__uninitialized_fill_n_a(this-&gt;_M_impl._M_start, __n, __value, _M_get_Tp_allocator());
}
// 据此，push_back 的源码便很好理解：finish 和 end_of_storage 指针不重合时直接插入，否则在尾部扩充空间
void push_back(const _Tp&amp; __x) {
    if (_M_finish != _M_end_of_storage) {
        construct(_M_finish, __x);
        ++_M_finish;
    }
    else{
        _M_insert_aux(end(), __x);
    }
}
template &lt;class _T1, class _T2&gt;
inline void _Construct(_T1* __p, const _T2&amp; __value) {
	new ((void*) __p) _T1(__value); // 使用 new 来构建 vector 的空间
}
template &lt;class _Tp, class _Alloc&gt;
void vector&lt;_Tp, _Alloc&gt;::_M_insert_aux(iterator __position, const _Tp&amp; __x)
{
	if (_M_finish != _M_end_of_storage) {
        // 在备用空间起始处构造一个元素并以 vector 最后一个元素值为其初值
        construct(_M_finish, *(_M_finish - 1));
        ++_M_finish;
        _Tp __x_copy = __x;
        copy_backward(__position, _M_finish - 2, _M_finish - 1);
        *__position = __x_copy;
    }
	else {
        // 扩容原则
        const size_type __old_size = size();
        const size_type __len = __old_size != 0 ? 2 * __old_size : 1;
        iterator __new_start = _M_allocate(__len);
        iterator __new_finish = __new_start;
        __STL_TRY {
            // 拷贝到新的 vector
            __new_finish = uninitialized_copy(_M_start, __position, __new_start);
            // 设置初值为 x
            construct(__new_finish, __x);
            ++__new_finish;
            // 将原备用空间的内容也拷贝过来
            __new_finish = uninitialized_copy(__position, _M_finish, __new_finish);
        }
        __STL_UNWIND((destroy(__new_start,__new_finish), 
                      _M_deallocate(__new_start,__len)));
        // 析构并释放原 vector
        destroy(begin(), end());
        _M_deallocate(_M_start, _M_end_of_storage - _M_start);
        // 调整迭代器使其指向新的 vector
        _M_start = __new_start;
        _M_finish = __new_finish;
        _M_end_of_storage = __new_start + __len;
    }
}

// 2.1.5 vector 的元素操作：pop_back, erase, clear, insert...
void pop_back() {
    --_M_finish; // 修改迭代器中尾指针的位置
    destroy(_M_finish); // 释放尾部空间
}
iterator erase(iterator __position) { // 清除某个位置上的空间
    if (__position + 1 != end())
        copy(__position + 1, _M_finish, __position); // 实现后续元素的前移拷贝
    --_M_finish; // 修改迭代器中尾指针的位置
    destroy(_M_finish); // 释放尾部空间
    return __position;
}
iterator erase(iterator __first, iterator __last) { // 清除 [first, last) 内元素
    iterator __i = copy(__last, _M_finish, __first); // [last, finish] 前移拷贝
    destroy(__i, _M_finish);
    _M_finish = _M_finish - (__last - __first); // 修改迭代器中尾指针的位置
    return __first;
}
void clear() {
    erase(begin(), end()); 
}
template &lt;class _Tp, class _Alloc&gt;
void vector&lt;_Tp, _Alloc&gt;::_M_fill_insert(iterator __position, size_type __n, 
const _Tp&amp; __x) // 从 position 开始插入 n 个元素，初值为 x
{
    if (__n != 0) {
        if (size_type(_M_end_of_storage - _M_finish) &gt;= __n) { // 备用空间足够
            _Tp __x_copy = __x;
            // 计算插入点后的现有元素个数
            const size_type __elems_after = _M_finish - __position; 
            iterator __old_finish = _M_finish;
            if (__elems_after &gt; __n) { // 插入点之后的现有元素个数 &gt; 新增元素个数
                uninitialized_copy(_M_finish - __n, _M_finish, _M_finish);
                _M_finish += __n; // 尾指针后移
                copy_backward(__position, __old_finish - __n, __old_finish);
                fill(__position, __position + __n, __x_copy); // 填入新值
            }
            else { // 插入点之后的现有元素个数 &lt;= 新增元素个数
                uninitialized_fill_n(_M_finish, __n - __elems_after, __x_copy);
                _M_finish += __n - __elems_after; // 分段插入
                uninitialized_copy(__position, __old_finish, _M_finish);
                _M_finish += __elems_after;
                fill(__position, __old_finish, __x_copy);
            }
        }
        else { // 备用空间不够
            // 确定新长度：
            // 旧空间 - 旧长度 &lt; 插入元素个数 &lt; 旧长度 --&gt; 旧长度的两倍
            // 插入元素个数更多时 --&gt; 旧长度 + 新增元素个数
            const size_type __old_size = size();        
            const size_type __len = __old_size + max(__old_size, __n);
            iterator __new_start = _M_allocate(__len);
            iterator __new_finish = __new_start;
            __STL_TRY {
                __new_finish = uninitialized_copy(_M_start, __position, __new_start); // 插入点之前的元素复制到新空间
                __new_finish = uninitialized_fill_n(__new_finish, __n, __x); // 新增元素插入到新空间
                __new_finish = uninitialized_copy(__position, _M_finish,__new_finish); // 插入点之后的元素复制到新空间
            }
            __STL_UNWIND((destroy(__new_start,__new_finish), 
                          _M_deallocate(__new_start,__len)));
            destroy(_M_start, _M_finish); // 释放旧 vector
            _M_deallocate(_M_start, _M_end_of_storage - _M_start);
            _M_start = __new_start; // 调整迭代器指针位置
            _M_finish = __new_finish;
            _M_end_of_storage = __new_start + __len;
        }
    }
}

// 2.1.6 关于 vector 的细节（可随时补充）
// 获取 vector 的第一个元素的地址：&amp;(*v.begin())
                         
// 2.1.7 部分方法的源码实现

template &lt;class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;
class vector : protected _Vector_base&lt;_Tp, _Alloc&gt; 
{
  // requirements:
  __STL_CLASS_REQUIRES(_Tp, _Assignable);

private:
  typedef _Vector_base&lt;_Tp, _Alloc&gt; _Base;
public:
  typedef _Tp value_type;
  typedef value_type* pointer;
  typedef const value_type* const_pointer;
  typedef value_type* iterator;
  typedef const value_type* const_iterator;
  typedef value_type&amp; reference;
  typedef const value_type&amp; const_reference;
  typedef size_t size_type;
  typedef ptrdiff_t difference_type;

protected:
#ifdef __STL_HAS_NAMESPACES
  using _Base::_M_allocate;
  using _Base::_M_deallocate;
  using _Base::_M_start;
  using _Base::_M_finish;
  using _Base::_M_end_of_storage;
#endif /* __STL_HAS_NAMESPACES */
public:
  vector&lt;_Tp, _Alloc&gt;&amp; operator=(const vector&lt;_Tp, _Alloc&gt;&amp; __x);
  void reserve(size_type __n) {
    if (capacity() &lt; __n) {
      const size_type __old_size = size();
      iterator __tmp = _M_allocate_and_copy(__n, _M_start, _M_finish);
      destroy(_M_start, _M_finish);
      _M_deallocate(_M_start, _M_end_of_storage - _M_start);
      _M_start = __tmp;
      _M_finish = __tmp + __old_size;
      _M_end_of_storage = _M_start + __n;
    }
  }

#endif /* __STL_MEMBER_TEMPLATES */

  reference front() { return *begin(); }
  const_reference front() const { return *begin(); }
  reference back() { return *(end() - 1); }
  const_reference back() const { return *(end() - 1); }

  void swap(vector&lt;_Tp, _Alloc&gt;&amp; __x) {
    __STD::swap(_M_start, __x._M_start);
    __STD::swap(_M_finish, __x._M_finish);
    __STD::swap(_M_end_of_storage, __x._M_end_of_storage);
  }

  void resize(size_type __new_size, const _Tp&amp; __x) {
    if (__new_size &lt; size()) 
      erase(begin() + __new_size, end());
    else
      insert(end(), __new_size - size(), __x);
  }
  void resize(size_type __new_size) { resize(__new_size, _Tp()); }
};
</code></pre>
<h3 id="list"><code>list</code></h3>
<pre><code class="language-C++">// 2.2 list
// 2.2.1 list 相对于 vector 的优缺点
// (1) 每次插入或删除一个元素，list 就配置或释放一个元素空间，对空间的利用十分精准
// (2) 对任何位置的元素插入或删除，时间复杂度永远为 O(1)
// (3) list 的插入和接合操作都不会造成迭代器的失效，而 vector 需进行人工干预
// (4) list 的存储空间不保证连续存在，因此迭代器不再具有随机存取的特性

// 2.2.2 list 节点
// list 的节点构成是一个双向链表的节点

struct _List_node_base {
  _List_node_base* _M_next;
  _List_node_base* _M_prev;
};
template &lt;class _Tp&gt;
struct _List_node : public _List_node_base {
  _Tp _M_data;
};

// 2.2.3 list 迭代器
// list 提供双向迭代器 (Bidirectional iterator) 以获得前移、后移的能力

struct _List_iterator_base {
  typedef size_t                     size_type;
  typedef ptrdiff_t                  difference_type;
  typedef bidirectional_iterator_tag iterator_category;

  _List_node_base* _M_node;

  _List_iterator_base(_List_node_base* __x) : _M_node(__x) {}
  _List_iterator_base() {}

  void _M_incr() { _M_node = _M_node-&gt;_M_next; }
  void _M_decr() { _M_node = _M_node-&gt;_M_prev; }

  bool operator==(const _List_iterator_base&amp; __x) const {
    return _M_node == __x._M_node; // 节点之间的判等
  }
  bool operator!=(const _List_iterator_base&amp; __x) const {
    return _M_node != __x._M_node; 
  }
};  

template&lt;class _Tp, class _Ref, class _Ptr&gt;
struct _List_iterator : public _List_iterator_base {
    typedef _List_iterator&lt;_Tp,_Tp&amp;,_Tp*&gt;             iterator;
    typedef _List_iterator&lt;_Tp,const _Tp&amp;,const _Tp*&gt; const_iterator;
    typedef _List_iterator&lt;_Tp,_Ref,_Ptr&gt;             _Self;

    typedef _Tp value_type;
    typedef _Ptr pointer;
    typedef _Ref reference;
    typedef _List_node&lt;_Tp&gt; _Node;

    _List_iterator(_Node* __x) : _List_iterator_base(__x) {}
    _List_iterator() {}
    _List_iterator(const iterator&amp; __x) : _List_iterator_base(__x._M_node) {}
    // 解引用运算符重载：取节点的数据值
    reference operator*() const { return ((_Node*) _M_node)-&gt;_M_data; }
    // 成员存取
    pointer operator-&gt;() const { return &amp;(operator*()); }
  
    _Self&amp; operator++() { 
        this-&gt;_M_incr(); // 前进一个节点
        return *this;
    }
    _Self operator++(int) { 
        _Self __tmp = *this;
        this-&gt;_M_incr();
        return __tmp;
    }
    _Self&amp; operator--() { 
        this-&gt;_M_decr(); // 后退一个节点
        return *this;
    }
    _Self operator--(int) { 
        _Self __tmp = *this;
        this-&gt;_M_decr();
        return __tmp;
    }
};

// 2.2.4 list 的继承关系：环状双向链表
// 环状双向链表的特性使得 list 只需要一个指针即可遍历整个链表

                    public                  protected
_List_alloc_base -----------&gt; _List_base ----------------&gt; list
        |                          
        |                          
        V                                                        
_List_node&lt;_Tp&gt;* _M_node   

public:
    explicit list(const allocator_type&amp; __a = allocator_type()) : _Base(__a) {}
	// 揭示了节点的真正位置：环状链表尾节点与头结点之间
    iterator begin()             { return (_Node*)(_M_node-&gt;_M_next); }
    const_iterator begin() const { return (_Node*)(_M_node-&gt;_M_next); }

    iterator end()             { return _M_node; }
    const_iterator end() const { return _M_node; }

    bool empty() const { return _M_node-&gt;_M_next == _M_node; }
    size_type size() const {
        size_type __result = 0;
        distance(begin(), end(), __result);
        return __result;
    }
    size_type max_size() const { return size_type(-1); }

    reference front() { return *begin(); }
    const_reference front() const { return *begin(); }
    reference back() { return *(--end()); } // 尾结点自减后的节点值
    const_reference back() const { return *(--end()); }

// 2.2.5 list 构造和内存管理：constructor, insert
// list 缺省使用 alloc 作为空间配置器，并另外定义一个 list_node_allocator, 则 list_node_allocator(n) 表示配置 n 个节点空间

typedef simple_alloc&lt;_List_node&lt;_Tp&gt;, _Alloc&gt; _Alloc_type;

_List_node&lt;_Tp&gt;* _M_get_node() { return _Alloc_type::allocate(1); }

void _M_put_node(_List_node&lt;_Tp&gt;* __p) { _Alloc_type::deallocate(__p, 1); }

_Node* _M_create_node(const _Tp&amp; __x) // 配置并构造一个节点
{
    _Node* __p = _M_get_node();
    __STL_TRY {
        _Construct(&amp;__p-&gt;_M_data, __x);
    }
    __STL_UNWIND(_M_put_node(__p));
    return __p;
}

iterator insert(iterator __position, const _Tp&amp; __x) {
    _Node* __tmp = _M_create_node(__x); // 构造一个初值为 x 的节点
    __tmp-&gt;_M_next = __position._M_node; // 修改双向链表的指针指向
    __tmp-&gt;_M_prev = __position._M_node-&gt;_M_prev;
    __position._M_node-&gt;_M_prev-&gt;_M_next = __tmp;
    __position._M_node-&gt;_M_prev = __tmp;
    return __tmp;
}

// 2.2.6 list 的元素操作：push_, erase, pop_, clear, remove, unique, splice, merge, reverse, sort, emplace

void push_front(const _Tp&amp; __x) { insert(begin(), __x); }
void push_back(const _Tp&amp; __x) { insert(end(), __x); }
void pop_front() { erase(begin()); }
void pop_back() { 
    iterator __tmp = end();
    erase(--__tmp); // end() 之前的节点是尾结点
}

iterator erase(iterator __position) {
    _List_node_base* __next_node = __position._M_node-&gt;_M_next;
    _List_node_base* __prev_node = __position._M_node-&gt;_M_prev;
    _Node* __n = (_Node*) __position._M_node;
    __prev_node-&gt;_M_next = __next_node; // 与链表删除结点方法一致
    __next_node-&gt;_M_prev = __prev_node;
    _Destroy(&amp;__n-&gt;_M_data);
    _M_put_node(__n);
    return iterator((_Node*) __next_node); // 返回值为旧节点不变的相对位置
}

template &lt;class _Tp, class _Alloc&gt;
void _List_base&lt;_Tp,_Alloc&gt;::clear() 
{
    _List_node&lt;_Tp&gt;* __cur = (_List_node&lt;_Tp&gt;*) _M_node-&gt;_M_next; // 从头遍历
    while (__cur != _M_node) {
        _List_node&lt;_Tp&gt;* __tmp = __cur;
        __cur = (_List_node&lt;_Tp&gt;*) __cur-&gt;_M_next;
        _Destroy(&amp;__tmp-&gt;_M_data);
        _M_put_node(__tmp);
    }
    _M_node-&gt;_M_next = _M_node; // list 的初始状态，与无参构造函数方法相同
    _M_node-&gt;_M_prev = _M_node;
}

template &lt;class _Tp, class _Alloc&gt;
void list&lt;_Tp, _Alloc&gt;::remove(const _Tp&amp; __value) // 删除所有值为 value 的元素
{
    iterator __first = begin();
    iterator __last = end();
    while (__first != __last) { // 从头遍历
        iterator __next = __first;
        ++__next;
        if (*__first == __value) erase(__first); // 删除该节点
        __first = __next;
    }
}

template &lt;class _Tp, class _Alloc&gt;
void list&lt;_Tp, _Alloc&gt;::unique()
{
    iterator __first = begin();
    iterator __last = end();
    if (__first == __last) return; // 链表为空时直接返回
    iterator __next = __first;
    while (++__next != __last) { // 从头遍历，此处原理决定了只能移除连续且相同的元素
        if (*__first == *__next)
            erase(__next); // 移除 [first, next] 内的相同元素
        else
            __first = __next;
        __next = __first;
    }
}

// 内部方法 transfer: 将连续范围内的元素迁移到某个特定位置之前
void transfer(iterator __position, iterator __first, iterator __last) {
    if (__position != __last) {
        // Remove [first, last) from its old position.
        __last._M_node-&gt;_M_prev-&gt;_M_next     = __position._M_node;
        __first._M_node-&gt;_M_prev-&gt;_M_next    = __last._M_node;
        __position._M_node-&gt;_M_prev-&gt;_M_next = __first._M_node; 

        // Splice [first, last) into its new position.
        _List_node_base* __tmp      = __position._M_node-&gt;_M_prev;
        __position._M_node-&gt;_M_prev = __last._M_node-&gt;_M_prev;
        __last._M_node-&gt;_M_prev     = __first._M_node-&gt;_M_prev; 
        __first._M_node-&gt;_M_prev    = __tmp;
    }
}

// splice: 借助 transfer 实现的接合函数
// 将 x 接合于 position 之前，不能指向同一个 list
void splice(iterator __position, list&amp; __x) { 
    if (!__x.empty()) 
        this-&gt;transfer(__position, __x.begin(), __x.end());
}
// 将 i 所指元素接合于 position 所指位置之前
void splice(iterator __position, list&amp;, iterator __i) { 
    iterator __j = __i;
    ++__j;
    if (__position == __i || __position == __j) return;
    this-&gt;transfer(__position, __i, __j);
}
// 将 [first, last) 内所有元素接合于 position 之前，指向同一 list 时 position 不能位于 [first, last) 之内
void splice(iterator __position, list&amp;, iterator __first, iterator __last) {
    if (__first != __last) 
        this-&gt;transfer(__position, __first, __last);
}
// merge: 将 x 合并到 *this, 两个 list 的内容必须先递增排序
template &lt;class _Tp, class _Alloc&gt;
void list&lt;_Tp, _Alloc&gt;::merge(list&lt;_Tp, _Alloc&gt;&amp; __x)
{
    iterator __first1 = begin();
    iterator __last1 = end();
    iterator __first2 = __x.begin();
    iterator __last2 = __x.end();
    while (__first1 != __last1 &amp;&amp; __first2 != __last2)
        if (*__first2 &lt; *__first1) {
            iterator __next = __first2;
            transfer(__first1, __first2, ++__next);
            __first2 = __next;
        }
	    else
    	    ++__first1;
    if (__first2 != __last2) transfer(__last1, __first2, __last2);
}

// reverse: 将 *this 的内容逆向重置
inline void __List_base_reverse(_List_node_base* __p)
{
    _List_node_base* __tmp = __p;
    do {
        __STD::swap(__tmp-&gt;_M_next, __tmp-&gt;_M_prev);
        __tmp = __tmp-&gt;_M_prev;     // Old next node is now prev.
    } while (__tmp != __p); // 判空
}

template &lt;class _Tp, class _Alloc&gt;
inline void list&lt;_Tp, _Alloc&gt;::reverse() 
{
	__List_base_reverse(this-&gt;_M_node);
}    

// sort: 采用快速排序对 list 进行排序
template &lt;class _Tp, class _Alloc&gt;
void list&lt;_Tp, _Alloc&gt;::sort()
{
    // Do nothing if the list has length 0 or 1.
    if (_M_node-&gt;_M_next != _M_node &amp;&amp; _M_node-&gt;_M_next-&gt;_M_next != _M_node) {
        list&lt;_Tp, _Alloc&gt; __carry;
        list&lt;_Tp, _Alloc&gt; __counter[64];
        int __fill = 0;
        while (!empty()) {
            __carry.splice(__carry.begin(), *this, begin());
            int __i = 0;
            while(__i &lt; __fill &amp;&amp; !__counter[__i].empty()) {
                __counter[__i].merge(__carry);
                __carry.swap(__counter[__i++]);
            }
            __carry.swap(__counter[__i]);         
            if (__i == __fill) ++__fill;
        } 

        for (int __i = 1; __i &lt; __fill; ++__i)
            __counter[__i].merge(__counter[__i-1]);
        swap(__counter[__fill-1]);
    }
}
</code></pre>
<h3 id="deque"><code>deque</code></h3>
<pre><code class="language-C++">// 2.3 deque
// 2.3.1 deque 的继承关系
                     public                  protected
_Deque_alloc_base -----------&gt; _Deque_base -------------&gt; deque
        |                          |
        |                          |                              迭代器包含指针
        V                          V                              _Tp* _M_cur;
   _Tp** _M_map    _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt; iterator --&gt;  _Tp* _M_first;
size_t _M_map_size          iterator _M_start                     _Tp* _M_last;
                            iterator _M_finish               _Map_pointer _M_node;

// 2.3.2 deque 底层实现
// 核心思想：没有容量 (capacity) 概念，以分段连续空间组合而成
// deque 采用一小块连续空间 (map) 作为主控，其中每个节点都是指针，指向另一端较大的连续线性空间（缓冲区），缓冲区是 deque 的储存空间主体，其大小默认为 512 字节

// 2.3.3 deque 的迭代器

template &lt;class _Tp, class _Ref, class _Ptr&gt;
struct _Deque_iterator { // 注意：未继承 std::iterator
    typedef _Deque_iterator&lt;_Tp, _Tp&amp;, _Tp*&gt;             iterator;
    typedef _Deque_iterator&lt;_Tp, const _Tp&amp;, const _Tp*&gt; const_iterator;

    // _S_buffer_size(): 决定缓冲区大小
    static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }
    inline size_t __deque_buf_size(size_t __size) {
        // 元素大小小于 512 --&gt; 512 / 元素大小
        // 元素大小大于等于 512 --&gt; 1
        return __size &lt; 512 ? size_t(512 / __size) : size_t(1);
    }

    typedef random_access_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _Ptr pointer;
    typedef _Ref reference;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Tp** _Map_pointer; // 二级指针指向

    typedef _Deque_iterator _Self;

    _Tp* _M_cur; // 当前迭代器访问元素位置
    _Tp* _M_first; // 片段起始位置
    _Tp* _M_last; // 片段最后一个未知的下一个位置
    _Map_pointer _M_node; // 中控器 map 中该连续片段所处的位置（管控中心）

    reference operator*() const { return *_M_cur; } // 当前所指的值
    pointer operator-&gt;() const { return _M_cur; } // 当前指针

    difference_type operator-(const _Self&amp; __x) const {
        return difference_type(_S_buffer_size()) * (_M_node - __x._M_node - 1) +
            (_M_cur - _M_first) + (__x._M_last - __x._M_cur);
    }

    _Self&amp; operator++() {
        ++_M_cur;
        if (_M_cur == _M_last) {
            _M_set_node(_M_node + 1); // 跳转到下一缓冲区的第一个元素
            _M_cur = _M_first;
        }
        return *this; 
    }
    _Self operator++(int)  { // 后置式
        _Self __tmp = *this;
        ++*this;
        return __tmp;
    }

    _Self&amp; operator--() {
        if (_M_cur == _M_first) {
            _M_set_node(_M_node - 1); // 跳转到上一缓冲区的最后一个元素
            _M_cur = _M_last;
        }
        --_M_cur;
        return *this;
    }
    _Self operator--(int) { // 后置式
        _Self __tmp = *this;
        --*this;
        return __tmp;
    }

    // 随机存取：迭代器跳跃 n 个距离
    _Self&amp; operator+=(difference_type __n)
    {
        difference_type __offset = __n + (_M_cur - _M_first);
        if (__offset &gt;= 0 &amp;&amp; __offset &lt; difference_type(_S_buffer_size()))
            _M_cur += __n; // 目标位置在同一缓冲区：直接与偏移量相加
        else {
            difference_type __node_offset =
                __offset &gt; 0 ? __offset / difference_type(_S_buffer_size())
                : -difference_type((-__offset - 1) / _S_buffer_size()) - 1;
            _M_set_node(_M_node + __node_offset); // 跳转至所在缓冲区
            _M_cur = _M_first + 
                (__offset - __node_offset * difference_type(_S_buffer_size()));
        }
        return *this;
    }

    _Self operator+(difference_type __n) const
    {
        _Self __tmp = *this;
        return __tmp += __n;
    }

    // 利用 operator+= 完成 operator-= 的重载
    _Self&amp; operator-=(difference_type __n) { return *this += -__n; }

    _Self operator-(difference_type __n) const {
        _Self __tmp = *this;
        return __tmp -= __n;
    }

    reference operator[](difference_type __n) const { return *(*this + __n); }

    bool operator==(const _Self&amp; __x) const { return _M_cur == __x._M_cur; }
    bool operator!=(const _Self&amp; __x) const { return !(*this == __x); }
    bool operator&lt;(const _Self&amp; __x) const {
        return (_M_node == __x._M_node) ? 
            (_M_cur &lt; __x._M_cur) : (_M_node &lt; __x._M_node);
    }
    bool operator&gt;(const _Self&amp; __x) const  { return __x &lt; *this; }
    bool operator&lt;=(const _Self&amp; __x) const { return !(__x &lt; *this); }
    bool operator&gt;=(const _Self&amp; __x) const { return !(*this &lt; __x); }

    void _M_set_node(_Map_pointer __new_node) { // 跳转到一个新的缓冲区，用于边缘
        _M_node = __new_node;
        _M_first = *__new_node;
        _M_last = _M_first + difference_type(_S_buffer_size());
    }
};

// 2.3.4 deque 的数据结构

template &lt;class _Tp, class _Alloc = __STL_DEFAULT_ALLOCATOR(_Tp) &gt;
class deque : protected _Deque_base&lt;_Tp, _Alloc&gt; {

    typedef _Deque_base&lt;_Tp, _Alloc&gt; _Base;
public:                         // Basic types
    typedef _Tp value_type;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type&amp; reference;
    typedef const value_type&amp; const_reference;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;

    typedef typename _Base::allocator_type allocator_type;
    allocator_type get_allocator() const { return _Base::get_allocator(); }

public:                         // Iterators
    typedef typename _Base::iterator       iterator;
    typedef typename _Base::const_iterator const_iterator;

    typedef reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
    typedef reverse_iterator&lt;iterator&gt; reverse_iterator;
    typedef reverse_iterator&lt;const_iterator, value_type, const_reference, 
    difference_type&gt;  
        const_reverse_iterator;
    typedef reverse_iterator&lt;iterator, value_type, reference, difference_type&gt;
        reverse_iterator; 

protected:                      // Internal typedefs
    typedef pointer* _Map_pointer;
    static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }

protected:
    using _Base::_M_initialize_map;
    using _Base::_M_create_nodes;
    using _Base::_M_destroy_nodes;
    using _Base::_M_allocate_node;
    using _Base::_M_deallocate_node;
    using _Base::_M_allocate_map;
    using _Base::_M_deallocate_map;

    using _Base::_M_map;
    using _Base::_M_map_size;
    using _Base::_M_start;
    using _Base::_M_finish;

public:                         // Basic accessors
    iterator begin() { return _M_start; }
    iterator end() { return _M_finish; }
    const_iterator begin() const { return _M_start; }
    const_iterator end() const { return _M_finish; }

    reverse_iterator rbegin() { return reverse_iterator(_M_finish); }
    reverse_iterator rend() { return reverse_iterator(_M_start); }
    const_reverse_iterator rbegin() const 
    { return const_reverse_iterator(_M_finish); }
    const_reverse_iterator rend() const 
    { return const_reverse_iterator(_M_start); }

    reference operator[](size_type __n)
    { return _M_start[difference_type(__n)]; }
    const_reference operator[](size_type __n) const 
    { return _M_start[difference_type(__n)]; }

    void _M_range_check(size_type __n) const {
        if (__n &gt;= this-&gt;size())
            __stl_throw_range_error(&quot;deque&quot;);
    }
    reference at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }
    const_reference at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    reference front() { return *_M_start; }
    reference back() { // 调用 operator-- 求得 end() 之前的指针
        iterator __tmp = _M_finish;
        --__tmp;
        return *__tmp;
    }
    const_reference front() const { return *_M_start; }
    const_reference back() const {
        const_iterator __tmp = _M_finish;
        --__tmp;
        return *__tmp;
    }

    size_type size() const { return _M_finish - _M_start; }
    size_type max_size() const { return size_type(-1); }
    bool empty() const { return _M_finish == _M_start; }

// 2.3.5 deque 的构造与内存管理：ctor, push_back, push_front

// fill_initialize(): 设置元素的初值
template &lt;class _Tp, class _Alloc&gt;
void deque&lt;_Tp,_Alloc&gt;::_M_fill_initialize(const value_type&amp; __value) {
    _Map_pointer __cur;
    __STL_TRY {
        for (__cur = _M_start._M_node; __cur &lt; _M_finish._M_node; ++__cur)
            // 为每个节点的缓冲区设定初值
            uninitialized_fill(*__cur, *__cur + _S_buffer_size(), __value);
        // 尾端的备用空间无需设初值
        uninitialized_fill(_M_finish._M_first, _M_finish._M_cur, __value);
    }
    __STL_UNWIND(destroy(_M_start, iterator(*__cur, __cur)));
}

// _M_initialize_map(): 产生并安排好 deque 的结构
template &lt;class _Tp, class _Alloc&gt;
void _Deque_base&lt;_Tp,_Alloc&gt;::_M_initialize_map(size_t __num_elements)
{
    // 需要节点数 = 元素个数 / 每个缓冲区可容纳的元素个数 + 1
    size_t __num_nodes = 
        __num_elements / __deque_buf_size(sizeof(_Tp)) + 1;
    
    /*
    inline size_t __deque_buf_size(size_t __size) {
    	// 若大于 512 则置为 1, 否则置为 512 / size
    	return __size &lt; 512 ? size_t(512 / __size) : size_t(1);
    }
    */

    // 一个 map 管理最少 8 个节点，最多 (所需节点数 + 2) 个节点
    // _M_map_size: map 的节点数
    _M_map_size = max((size_t) _S_initial_map_size, __num_nodes + 2);
    _M_map = _M_allocate_map(_M_map_size);

    // 令 nstart 和 nfinish 指向 map 的最中间区段
    _Tp** __nstart = _M_map + (_M_map_size - __num_nodes) / 2;
    _Tp** __nfinish = __nstart + __num_nodes;

    __STL_TRY {
        _M_create_nodes(__nstart, __nfinish);
        
        /*
        template &lt;class _Tp, class _Alloc&gt;
        void _Deque_base&lt;_Tp,_Alloc&gt;::_M_create_nodes(_Tp** __nstart,
                                                      _Tp** __nfinish)
        {
              _Tp** __cur;
              __STL_TRY {
                // 为每个节点配置缓冲区，所有缓冲区之和为 deque 的可用空间
                for (__cur = __nstart; __cur &lt; __nfinish; ++__cur)
                  *__cur = _M_allocate_node();
              }
              __STL_UNWIND(_M_destroy_nodes(__nstart, __cur));
        }
        */
    }
    __STL_UNWIND((_M_deallocate_map(_M_map, _M_map_size), 
                  _M_map = 0, _M_map_size = 0));
    _M_start._M_set_node(__nstart);
    _M_finish._M_set_node(__nfinish - 1);
    _M_start._M_cur = _M_start._M_first;
    // 需要节点数刚好整除时多加一个节点，cur 指向该节点的起始处
    _M_finish._M_cur = _M_finish._M_first +
        __num_elements % __deque_buf_size(sizeof(_Tp)); 
}
    
// push_back: 尾部插入元素
void push_back(const value_type&amp; __t) {
    if (_M_finish._M_cur != _M_finish._M_last - 1) {
        construct(_M_finish._M_cur, __t);
        ++_M_finish._M_cur;
    }
    else
        _M_push_back_aux(__t); // 无备用空间时，分配新的缓冲区
    /*
    template &lt;class _Tp, class _Alloc&gt;
    void deque&lt;_Tp,_Alloc&gt;::_M_push_back_aux()
    {
        _M_reserve_map_at_back();
        *(_M_finish._M_node + 1) = _M_allocate_node(); // 配置新的缓冲区
        __STL_TRY {
            construct(_M_finish._M_cur); 
            _M_finish._M_set_node(_M_finish._M_node + 1);
            _M_finish._M_cur = _M_finish._M_first; // 设定 finish
        }
        // 如不能全部成功，则全部销毁
        __STL_UNWIND(_M_deallocate_node(*(_M_finish._M_node + 1)));
    }
    */
}

// push_front: 头部插入元素
void push_front(const value_type&amp; __t) {
    if (_M_start._M_cur != _M_start._M_first) {
        construct(_M_start._M_cur - 1, __t);
        --_M_start._M_cur;
    }
    else
        _M_push_front_aux(__t);
    /*
    template &lt;class _Tp, class _Alloc&gt;
    void  deque&lt;_Tp,_Alloc&gt;::_M_push_front_aux(const value_type&amp; __t)
    {
          value_type __t_copy = __t;
          _M_reserve_map_at_front();
          *(_M_start._M_node - 1) = _M_allocate_node(); // 配置新的缓冲区
          __STL_TRY {
                _M_start._M_set_node(_M_start._M_node - 1);
                _M_start._M_cur = _M_start._M_last - 1; // 设置 start
                construct(_M_start._M_cur, __t_copy);
          }
          // 如不能全部成功，则全部销毁
          __STL_UNWIND((++_M_start, _M_deallocate_node(*(_M_start._M_node - 1))));
    } 

    */
}

// push_back/push_front 中备用空间不足时的策略：reserve_map_at_back/reserve_map_at_front ------&gt; reallocate_map
    
void _M_reserve_map_at_back (size_type __nodes_to_add = 1) {
    // 尾结点后备用空间不足
    if (__nodes_to_add + 1 &gt; _M_map_size - (_M_finish._M_node - _M_map))
        _M_reallocate_map(__nodes_to_add, false);
}
void _M_reserve_map_at_front (size_type __nodes_to_add = 1) {
    // 头结点前备用空间不足
    if (__nodes_to_add &gt; size_type(_M_start._M_node - _M_map))
        _M_reallocate_map(__nodes_to_add, true);
}
template &lt;class _Tp, class _Alloc&gt;
void deque&lt;_Tp,_Alloc&gt;::_M_reallocate_map(size_type __nodes_to_add,
                                          bool __add_at_front)
{
    size_type __old_num_nodes = _M_finish._M_node - _M_start._M_node + 1;
    size_type __new_num_nodes = __old_num_nodes + __nodes_to_add;

    _Map_pointer __new_nstart;
    if (_M_map_size &gt; 2 * __new_num_nodes) {
        __new_nstart = _M_map + (_M_map_size - __new_num_nodes) / 2 
            + (__add_at_front ? __nodes_to_add : 0);
        if (__new_nstart &lt; _M_start._M_node)
            copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);
        else
            copy_backward(_M_start._M_node, _M_finish._M_node + 1, 
                          __new_nstart + __old_num_nodes);
    }
    else {
        size_type __new_map_size = 
            _M_map_size + max(_M_map_size, __nodes_to_add) + 2;
        
        // 开辟新空间给新的 map 使用
        _Map_pointer __new_map = _M_allocate_map(__new_map_size);
        __new_nstart = __new_map + (__new_map_size - __new_num_nodes) / 2
            + (__add_at_front ? __nodes_to_add : 0);
        // 将原 map 内容拷贝过来
        copy(_M_start._M_node, _M_finish._M_node + 1, __new_nstart);
        // 释放原 map 的空间
        _M_deallocate_map(_M_map, _M_map_size);
        // 设置新 map 的起始地址与大小
        _M_map = __new_map;
        _M_map_size = __new_map_size;
    }
	// 设置迭代器 start 和 finish
    _M_start._M_set_node(__new_nstart);
    _M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);
}

// 2.3.6 deque 的元素操作：pop_back, pop_front, clear, erase, insert

// pop_back/pop_front: 从尾部（头部）移除元素
void pop_back() {
    if (_M_finish._M_cur != _M_finish._M_first) {
        --_M_finish._M_cur;
        destroy(_M_finish._M_cur);
    }
    else
        _M_pop_back_aux(); // 缓冲区无元素
        /*
        template &lt;class _Tp, class _Alloc&gt;
        void deque&lt;_Tp,_Alloc&gt;::_M_pop_back_aux()
        {
            _M_deallocate_node(_M_finish._M_first); // 先释放最后一个缓冲区
            _M_finish._M_set_node(_M_finish._M_node - 1);
            _M_finish._M_cur = _M_finish._M_last - 1; // finish 指向上个缓冲区尾元素
            destroy(_M_finish._M_cur); // 析构该元素
        }
        */
}
void pop_front() {
    if (_M_start._M_cur != _M_start._M_last - 1) {
        destroy(_M_start._M_cur);
        ++_M_start._M_cur;
    }
    else 
        _M_pop_front_aux(); // 第一个缓冲区仅有一个元素
        /*
        template &lt;class _Tp, class _Alloc&gt;
        void deque&lt;_Tp,_Alloc&gt;::_M_pop_front_aux()
        {
            destroy(_M_start._M_cur); // 析构第一个缓冲区仅有的元素
            _M_deallocate_node(_M_start._M_first); // 释放第一个缓冲区
            _M_start._M_set_node(_M_start._M_node + 1); 
            _M_start._M_cur = _M_start._M_first; // start 指向下一个缓冲区头元素
        }      
        */
}
    
// clear: 清除 deque 并使其恢复至初始状态
// 特别注意：deque 的最初状态是存在一个缓冲区，因此不能将缓冲区全部销毁   
template &lt;class _Tp, class _Alloc&gt; 
void deque&lt;_Tp,_Alloc&gt;::clear()
{
    for (_Map_pointer __node = _M_start._M_node + 1;
         __node &lt; _M_finish._M_node;
         ++__node) { // 遍历头尾缓冲区之间的缓冲区并将其全部销毁
        destroy(*__node, *__node + _S_buffer_size());
        _M_deallocate_node(*__node);
    }
	// 此时只剩至多两个缓冲区，根据缓冲区数量分类讨论
    if (_M_start._M_node != _M_finish._M_node) { // 缓冲区数量为 2
        destroy(_M_start._M_cur, _M_start._M_last); // 头尾缓冲区的元素全部析构
        destroy(_M_finish._M_first, _M_finish._M_cur); 
        _M_deallocate_node(_M_finish._M_first); // 销毁尾缓冲区，保留头缓冲区
    }
    else
        destroy(_M_start._M_cur, _M_finish._M_cur); // 将缓冲区内元素全部析构

    _M_finish = _M_start; // 重置指针
}

// erase: 清除 pos 处的元素 / 清除 [first, last) 内的所有元素

iterator erase(iterator __pos) {
    iterator __next = __pos;
    ++__next;
    difference_type __index = __pos - _M_start;
    if (size_type(__index) &lt; (this-&gt;size() &gt;&gt; 1)) { // 元素处于前半部分
        copy_backward(_M_start, __pos, __next); // 将目标之前的元素拷贝到该坐标之后
        pop_front(); // 从头部弹出该元素
    }
    else {
        copy(__next, _M_finish, __pos); // 将目标之后的元素拷贝到坐标之前
        pop_back(); // 从尾部弹出该元素
    }
    return _M_start + __index; // 返回相对位置相同的指针
}
template &lt;class _Tp, class _Alloc&gt;
typename deque&lt;_Tp,_Alloc&gt;::iterator 
deque&lt;_Tp,_Alloc&gt;::erase(iterator __first, iterator __last)
{
    if (__first == _M_start &amp;&amp; __last == _M_finish) { // 清除整个 deque
        clear();
        return _M_finish;
    }
    else { // 与删除单个元素策略一致：分析区间相对位置 --&gt; 向前或向后拷贝
        difference_type __n = __last - __first; // 清除区间长度
        difference_type __elems_before = __first - _M_start; // 清除区间前方元素个数
        if (__elems_before &lt; difference_type((this-&gt;size() - __n) / 2)) {
            copy_backward(_M_start, __first, __last);
            iterator __new_start = _M_start + __n;
            destroy(_M_start, __new_start);
            _M_destroy_nodes(__new_start._M_node, _M_start._M_node);
            _M_start = __new_start;
        }
        else {
            copy(__last, _M_finish, __first);
            iterator __new_finish = _M_finish - __n;
            destroy(__new_finish, _M_finish);
            _M_destroy_nodes(__new_finish._M_node + 1, _M_finish._M_node + 1);
            _M_finish = __new_finish;
        }
        return _M_start + __elems_before;
    }
}
    
// insert（最重要版本）: 在某个点（之前）插入一个值
    
iterator insert(iterator position, const value_type&amp; __x) {
    if (position._M_cur == _M_start._M_cur) { // 插入点是最前端
        push_front(__x);
        return _M_start;
    }
    else if (position._M_cur == _M_finish._M_cur) { // 插入点是最尾端
        push_back(__x);
        iterator __tmp = _M_finish;
        --__tmp;
        return __tmp; 
    }
    else {
        return _M_insert_aux(position, __x);
        /* 策略与 erase 删除单个元素相同：判断相对位置 ----&gt; 向前或向后拷贝元素
        template &lt;class _Tp, class _Alloc&gt;
        typename deque&lt;_Tp, _Alloc&gt;::iterator
        deque&lt;_Tp,_Alloc&gt;::_M_insert_aux(iterator __pos, const value_type&amp; __x)
        {
            difference_type __index = __pos - _M_start;
            value_type __x_copy = __x;
            if (size_type(__index) &lt; this-&gt;size() / 2) {
                push_front(front());
                iterator __front1 = _M_start;
                ++__front1;
                iterator __front2 = __front1;
                ++__front2;
                __pos = _M_start + __index;
                iterator __pos1 = __pos;
                ++__pos1;
                copy(__front2, __pos1, __front1);
            }
            else {
                push_back(back());
                iterator __back1 = _M_finish;
                --__back1;
                iterator __back2 = __back1;
                --__back2;
                __pos = _M_start + __index;
                copy_backward(__pos, __back2, __back1);
            }
            *__pos = __x_copy;
            return __pos;
        }
        */
    }
}
</code></pre>
<h3 id="priority_queue"><code>priority_queue</code></h3>
<pre><code class="language-C++">// 复习堆排序
</code></pre>
<h3 id="空间配置器">空间配置器</h3>
<pre><code class="language-C++">// C++ new/delete 内存配置与释放操作与 stl allocator 的对应关系：
// new 配置内存 --&gt; 调用构造函数创建对象 --&gt; 调用析构函数析构对象 --&gt; delete 释放内存
alloc::allocate()      construct()            destroy()            deallocate()
    
/* 1. construct() 和 destroy() */

template &lt;class _T1, class _T2&gt;
inline void construct(_T1* __p, const _T2&amp; __value) {
	_Construct(__p, __value);
    /*
    template &lt;class _T1, class _T2&gt;
    inline void _Construct(_T1* __p, const _T2&amp; __value) {
    	new ((void*) __p) _T1(__value);
    }
    */
}

template &lt;class _T1&gt;
inline void construct(_T1* __p) {
	_Construct(__p);
    /*
    template &lt;class _T1&gt;
    inline void _Construct(_T1* __p) {
    	new ((void*) __p) _T1();
    }
    */
}

template &lt;class _Tp&gt;
inline void destroy(_Tp* __pointer) {
	_Destroy(__pointer);
    /*
    template &lt;class _Tp&gt;
    inline void _Destroy(_Tp* __pointer) {
    	__pointer-&gt;~_Tp(); // 仅析构一个指针
    }
    */
}

template &lt;class _ForwardIterator&gt;
inline void destroy(_ForwardIterator __first, _ForwardIterator __last) {
	_Destroy(__first, __last);
    /*
    template &lt;class _ForwardIterator&gt;
    inline void _Destroy(_ForwardIterator __first, _ForwardIterator __last) {
    	__destroy(__first, __last, __VALUE_TYPE(__first));
    	     |
    	     V
    	template &lt;class _ForwardIterator, class _Tp&gt;
        inline void __destroy(_ForwardIterator __first, _ForwardIterator __last, _Tp*)
        {
        	typedef typename __type_traits&lt;_Tp&gt;::has_trivial_destructor
                  _Trivial_destructor;
        	__destroy_aux(__first, __last, _Trivial_destructor());
        	      |
        	      V
        	
        	template &lt;class _ForwardIterator&gt;
            void __destroy_aux(_ForwardIterator __first, _ForwardIterator __last, __false_type) // 通过类型萃取获取了元素的类型
            {
            	for ( ; __first != __last; ++__first)
            		destroy(&amp;*__first); // 调用隐式析构函数
            }
        }
    }
    */
}

/* 2. 空间的配置与释放 */
// 核心思想：operator new()/operator delete() ----&gt; malloc()/free()


</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://yzqaveiro.github.io/tag/McDYiKLjQ/" class="tag">
                    C++
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://yzqaveiro.github.io/post/hello-gridea/">
                  <h3 class="post-title">
                    Hello YZQAveiro
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
