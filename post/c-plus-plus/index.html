<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>C++ Day01: C++基础 | YZQAveiro</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://yzqaveiro.github.io/favicon.ico?v=1651041762726">
<link rel="stylesheet" href="https://yzqaveiro.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="

1. 命名空间：避免重复命名
2. const
3.  new/delete
4.  引用
5.  强制转换
6.  函数重载
7.  默认参数
8.  bool 类型
9. 内联函数 inline
10. 异常安全
11. C/C++..." />
    <meta name="keywords" content="C++" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://yzqaveiro.github.io">
        <img src="https://yzqaveiro.github.io/images/avatar.png?v=1651041762726" class="site-logo">
        <h1 class="site-title">YZQAveiro</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      Welcome to YZQAveiro's Blog!
    </div>
    <div class="site-footer">
       | <a class="rss" href="https://yzqaveiro.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">C++ Day01: C++基础</h2>
            <div class="post-date">2022-04-26</div>
            
            <div class="post-content" v-pre>
              <p><img src="https://yzqaveiro.github.io/post-images/1650977806552.png" alt="" loading="lazy"><br>
<ul class="markdownIt-TOC">
<li><a href="#1-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D%E5%91%BD%E5%90%8D">1. 命名空间：避免重复命名</a></li>
<li><a href="#2-const">2. const</a></li>
<li><a href="#3-newdelete">3.  new/delete</a></li>
<li><a href="#4-%E5%BC%95%E7%94%A8">4.  引用</a></li>
<li><a href="#5-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2">5.  强制转换</a></li>
<li><a href="#6-%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD">6.  函数重载</a></li>
<li><a href="#7-%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0">7.  默认参数</a></li>
<li><a href="#8-bool-%E7%B1%BB%E5%9E%8B">8.  bool 类型</a></li>
<li><a href="#9-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-inline">9. 内联函数 inline</a></li>
<li><a href="#10-%E5%BC%82%E5%B8%B8%E5%AE%89%E5%85%A8">10. 异常安全</a></li>
<li><a href="#11-cc-%E9%A3%8E%E6%A0%BC%E5%AD%97%E7%AC%A6%E4%B8%B2">11. C/C++ 风格字符串</a></li>
</ul>
</p>
<h1 id="1-命名空间避免重复命名">1. 命名空间：避免重复命名</h1>
<p>(1) 命名空间的定义<br>
<strong>命名空间</strong>是一个由用户自己定义的作用域，在不同作用域中可以定义相同名字的变量或函数，这些变量或函数被称为<strong>实体</strong>（也可以是常量、结构体、类等），其可见域始于实体创建，终于所在命名空间结束。</p>
<p>(2) 命名空间的使用方式</p>
<p>① <code>using</code> 编译指令</p>
<pre><code class="language-c++">using namespace std; // 标准命名空间
</code></pre>
<p>② 作用域限定符</p>
<pre><code class="language-c++">int main()
{
	std::cout &lt;&lt; &quot;Hello&quot; &lt;&lt; std::endl; // 使用 :: 符号来调用命名空间内的实体    
}
</code></pre>
<p>③ <code>using</code> 声明机制</p>
<pre><code class="language-c++">using std::cout;
using std::endl;
int main()
{
	cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl; // using 的作用域是从 using 语句开始到所在作用域结束
}
</code></pre>
<p>④ 匿名命名空间</p>
<pre><code class="language-c++">namespace // 匿名命名空间没有名字，只能在本文件的作用域内有效，其作用域是匿名命名空间的声明语句开始到文件结束
{

int val = 0; // 可以在本模块内部使用，类似 static 变量
void func()
{
	cout &lt;&lt; &quot;Hello&quot; &lt;&lt; endl;
}
    
}
</code></pre>
<h1 id="2-const">2. const</h1>
<p>(1) <code>const</code> 修饰变量</p>
<pre><code class="language-c++">const int num1 = 10;
int const num2 = 20;
const int val; // 错误写法，使用 const 关键字修饰的变量必须要初始化
</code></pre>
<p>(2) <code>const</code> 修饰指针<br>
① 常量指针</p>
<pre><code class="language-c++">int num1 = 10, num2 = 20;
const int* p1 = &amp;num1; 
*p1 = 100; // 错误，不能修改所指内容的值
p1 = &amp;num2; // 正确，可以改变指针的指向
int const* p2 = &amp;num1; // 实质同 p1
</code></pre>
<p>② 指针常量</p>
<pre><code class="language-c++">int* const p3 = &amp;num1; 
*p3 = 100; // 正确，可以改变所指内容的值
p3 = &amp;num2; // 错误，不能改变指针的指向
</code></pre>
<p>③ <code>const</code>指针常量</p>
<pre><code class="language-c++">const int* const p4 = &amp;num1; // 所指内容的值和指针的指向均不能改变
</code></pre>
<h1 id="3-newdelete">3.  new/delete</h1>
<p>(1) 开辟一个元素的空间</p>
<pre><code class="language-c++">int* p = new int(1); // 将整型指针所指的值初始化为括号内的值
</code></pre>
<p>(2) 开辟一个数组的空间</p>
<pre><code class="language-c++">int* p = new int[10](); // [] 内定义了数组大小，所有元素初始化为 0
</code></pre>
<blockquote>
<p>常考题：new/delete 表达式与 malloc/free 的区别与联系</p>
<ol>
<li>malloc/free 是 C/C++ 语言的标准库函数，new/delete 是 C++ 的表达式</li>
<li>new 能够自动分配空间大小，malloc 需要传入参数</li>
<li>new 开辟空间的同时还对空间做了初始化的操作，而 malloc 不行</li>
<li>new/delete 能对对象进行构造和析构函数的调用，进而对内存进行更加详细的工作，而malloc/free 不能</li>
<li>new/delete 的功能完全覆盖了 malloc/free, 但 C++ 程序经常要调用 C 函数，而 C 程序只能用 malloc/free 管理动态内存，因此 C++ 中仍保留 malloc/free</li>
</ol>
</blockquote>
<h1 id="4-引用">4.  引用</h1>
<p>引用的定义：一个已定义变量的别名<br>
引用的本质：间接寻址 (* const)<br>
(1) 引用作为函数参数（以两数交换为例）</p>
<pre><code class="language-c++">void swap(int x, int y) // 值传递，本质是将参数拷贝进函数栈，无法实现两数交换
{
	int temp = x;
	x = y;
	y = temp;
}

void swap(int *pa, int *pb) // 用指针作为参数，本质仍为值传递
{
    int temp = *pa;
    *pa = *pb;
    *pb = temp;
}

void swap(int &amp;x, int &amp;y) // 引用作为参数
{
	int temp = x;
	x = y;
	y = temp;
}
</code></pre>
<p>(2) 引用作为函数返回值</p>
<pre><code class="language-c++">int func1() // 当函数返回时，会对 temp 进行复制
{
    temp = 100;
    return temp; // 此处会进行复制操作
}
int&amp; func2() // 当函数返回时，不会对 temp 进行复制，因为返回的是引用
{
    temp = 1000;
    return temp;
}

int num = func2() + 1; // 错误，会发生内存泄露
</code></pre>
<h1 id="5-强制转换">5.  强制转换</h1>
<p>(1) <code>static_cast</code><br>
<code>static_cast</code>的用法主要有以下几种：</p>
<ol>
<li>用于基本数据类型之间的转换，如把 <code>int</code> 转成 <code>char</code>, 把 <code>int</code> 转成 <code>enum</code></li>
<li>把 <code>void</code> 指针转换成目标类型的指针，但不安全（注意：不能随意转换两个任意类型的指针）</li>
<li>把任何类型的表达式转换成 <code>void</code> 类型</li>
<li>用于类层次结构中基类和派生类之间指针或引用的转换。进行上行转换（把派生类的指针或引用转换成基类指针或引用）是安全的；进行下行转换（把基类指针或引用转换成派生类指针或引用）时，由于没有动态类型检查，所以是不安全的</li>
</ol>
<pre><code class="language-c++">int iNumber = 100;
float fNumber = 0;
fNumber = (float) iNumber; // C 中的强制转换
fNumber = static_cast&lt;float&gt;(iNumber);

void *pVoid = malloc(sizeof(int));
int *pInt = static_cast&lt;int*&gt;(pVoid); // 将 void 指针转换为其他类型的指针
float *pFloat = static_cast&lt;float *&gt;(pInt);// 错误，不能在任意的指针类型间转换
</code></pre>
<p>(2) <code>const_cast</code><br>
该运算符用来修改类型的 <code>const</code> 属性。常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。</p>
<pre><code class="language-c++">const int num = 1;
const int* p1 = &amp;num;
int* p2 = const_cast&lt;int*&gt;(&amp;num); // 将 const int* 转换为 int*
</code></pre>
<h1 id="6-函数重载">6.  函数重载</h1>
<p>C++ 进行函数重载的实现原理叫<strong>名字改编 (name mangling)</strong>, 具体的规则是:<br>
(1) 函数名称必须相同<br>
(2) 参数列表必须不同（参数的类型不同、个数不同、顺序不同）<br>
(3) 函数的返回类型可以相同也可以不相同<br>
(4) 仅仅返回类型不同不足以成为函数的重载</p>
<pre><code class="language-c++">int add(int x, int y);
int add(int x, int y, int z);

// 通过 nm [filename] 查看调用函数信息
0000000000001169 T _Z3addii
0000000000001181 T _Z3addiii
</code></pre>
<blockquote>
<p><code>extern &quot;C&quot;</code><br>
C++ 源码中，如需某些代码按 C 的方式调用，必须将其放入 <code>extern &quot;C&quot; {}</code> 中<br>
可用 <code>#ifdef __cplusplus</code> <code>#endif</code> 来使 C++ 编译器使用 C 编译方式编译宏定义内代码<br>
0000000000001169 T add</p>
</blockquote>
<h1 id="7-默认参数">7.  默认参数</h1>
<p>不为函数传递实参时，函数可按事先定义好的默认参数运行，通常将默认参数设置在<strong>函数声明</strong>中</p>
<pre><code class="language-c++">void func1(int a = 0, int b = 0, int c = 0, int d = 0);
void func1(int a = 0, int b, int c, int d = 0); // 错误，一旦设置默认参数，后续参数均需设置默认参数
</code></pre>
<h1 id="8-bool-类型">8.  bool 类型</h1>
<p><code>true: 1 false: 0</code><br>
① 任何数字或指针值都可以隐式转换为 <code>bool</code> 值<br>
② 任何非零值都将转换为 true, 而零值转换为 false<br>
③ 一个 <code>bool</code> 类型的值所占内存大小为 1</p>
<h1 id="9-内联函数-inline">9. 内联函数 inline</h1>
<p>(1) 内联函数的定义<br>
内联函数是 C++ 特有的特性，用于降低程序的运行时间。在编译阶段，编译器将内联函数的定义体替代函数调用语句，从而实现类似带参数宏定义的效果。<br>
(2) 将内联函数放入头文件<br>
<code>inline</code> 关键字必须与函数定义体放在一起才能构成内联函数，即：</p>
<pre><code class="language-c++">// 原则：声明前不加 inline, 定义前加 inline
inline void func(int x, int y){
	// function
}
</code></pre>
<p>(3) 使用 <code>inline</code> 函数的时机<br>
① 需要反复调用且结构较为简单，不包含 <code>for</code>, <code>while</code>, <code>switch</code>以及递归等复杂结构的函数<br>
② 作为类的接口函数读写类的私有或保护成员</p>
<blockquote>
<p>常考题：inline 和宏定义的区别？<br>
① 内联函数会被放入符号表中，在编译阶段展开；宏定义是简单的字符串替换，在预处理阶段展开<br>
② 内联函数拥有类型检测、语法判断等普通函数特性</p>
</blockquote>
<h1 id="10-异常安全">10. 异常安全</h1>
<p>C++ 处理异常的三个关键字：<code>try</code>, <code>catch</code>, <code>throw</code><br>
(1) <code>throw</code>: 问题出现时，程序通过使用 <code>throw</code> 抛出异常<br>
格式：throw [表达式];</p>
<p>(2) try-catch 语句块：标识特定的异常并进行捕获<br>
基本流程：执行 <code>try</code> 块中的语句 --&gt; 如果执行的过程中没有异常拋出，那么执行完后就执行最后一个 <code>catch</code> 块后面的语句，所有 <code>catch</code> 块中的语句都不会被执行；如果 <code>try</code> 块执行的过程中拋出了异常，那么拋出异常后立即跳转到第一个异常类型和拋出的异常类型匹配的 <code>catch</code> 块中执行（称作异常被该 <code>catch</code> 块捕获），执行完后再跳转到最后一个 <code>catch</code> 块后面继续执行</p>
<pre><code class="language-c++">try{
    // function...
}catch(std::exception&amp; e){
    cerr &lt;&lt; e.what() &lt;&lt; endl;
}
</code></pre>
<h1 id="11-cc-风格字符串">11. C/C++ 风格字符串</h1>
<p>(1) C 风格字符串<br>
C 风格字符串是以 '\0' 为结尾的<strong>字符数组</strong>， 常用的字符串处理函数有：</p>
<pre><code class="language-c">// 返回 str 的长度，不包括 null 结束符
size_t strlen( const char *str ); 

// 比较lhs和rhs是否相同。lhs等于rhs,返回0; lhs大于rhs，返回正数; lhs小于rhs，返回负数
int strcmp( const char *lhs, const char *rhs );
int strncmp( const char *lhs, const char *rhs, size_t count );

// 在 str 中查找首次出现 ch 字符的位置；查找不到，返回空指针
char *strchr( const char *str, int ch );

// 在 str 中查找首次出现子串 substr 的位置；查找不到，返回空指针
char *strstr( const char* str, const char* substr );

// 字符控制函数 (修改式操作)
char *strcpy(char *dest, const char *src); // 将 src 复制给 dest, 返回 dest
char *strncpy(char *dest, const char *src, size_t count);
char *strcat( char *dest, const char *src ); // 拼接
char *strncat( char *dest, const char *src, size_t count );

// memset 的取代方案
void *memset( void *dest, int ch, size_t count ); // memset(str, 0, sizeof(str));
void* memcpy( void *dest, const void *src, size_t count );
extern void bzero (void *__s, size_t __n);
</code></pre>
<p>(2) C++风格字符串：<code>std::string</code><br>
① <code>string</code> 对象的构造<br>
<strong>注意：每种构造函数的最后一个隐式参数均被认为是空间配置器，未自定义时设为默认</strong></p>
<ol>
<li>默认构造函数，生成一个空字符串</li>
</ol>
<pre><code class="language-c++">string(); // 大小为 0, 容量未指定
</code></pre>
<ol start="2">
<li>通过 C 风格字符串构造一个 string 对象</li>
</ol>
<pre><code class="language-c++">string(const char* rhs);
</code></pre>
<ol start="3">
<li>通过 rhs 的前 n 个字符构造一个 string 对象</li>
</ol>
<pre><code class="language-c++">string(const char* rhs, size_type n);
</code></pre>
<ol start="4">
<li>复制构造函数</li>
</ol>
<pre><code class="language-c++">string(const string&amp; rhs);
</code></pre>
<ol start="5">
<li>生成一个 string 对象，包含 n 个 c 字符</li>
</ol>
<pre><code class="language-c++">string(size_type n, char c);
</code></pre>
<ol start="6">
<li>以区间 [first, last) 内的字符创建一个 string 对象</li>
</ol>
<pre><code class="language-c++">string(InputIt first, InputIt last); 
// 相当于 string(static_cast&lt;size_type&gt;(first), static_cast&lt;size_type&gt;(second), alloc);
</code></pre>
<p>② <code>string</code> 与 C 风格字符串的转换</p>
<pre><code class="language-c++">string str = &quot;hello&quot;;
const char* cstr1 = str.c_str();
const char* cstr2 = str.data(); // c_str() 和 data() 的底层实现相同
</code></pre>
<p>③ 元素遍历和存取</p>
<ol>
<li>使用运算符 [] 或 at() 访问</li>
</ol>
<pre><code class="language-c++">reference operator[]( size_type pos );// 返回下标为 pos 的元素
const_reference operator[]( size_type pos ) const;
reference at( size_type pos );// 返回下标为 pos 的元素
const_reference at( size_type pos ) const;

// 示例
string str = &quot;hello&quot;;
cout &lt;&lt; str[0] &lt;&lt; &quot; &quot; &lt;&lt; str.at(1) &lt;&lt; endl; // h e
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://yzqaveiro.github.io/tag/McDYiKLjQ/" class="tag">
                    C++
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://yzqaveiro.github.io/post/hello-yzqaveiro/">
                  <h3 class="post-title">
                    Hello, YZQAveiro
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
